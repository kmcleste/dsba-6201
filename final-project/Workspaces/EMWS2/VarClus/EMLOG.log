*------------------------------------------------------------*
User:                Kyle McLester
Date:                April 13, 2022
Time:                13:21:01
Site:                70080897
Platform:            X64_10HOME
Maintenance Release: 9.04.01M6P111518
EM Version:          15.1
* 
*------------------------------------------------------------*
* Training Log
Date:                April 13, 2022
Time:                13:20:46
*------------------------------------------------------------*
15225  proc freq data=EMWS2.VarClus_VariableSet noprint;
15226  table ROLE*LEVEL/out=WORK.VarClusMETA;
15227  run;
 
NOTE: There were 98 observations read from the data set EMWS2.VARCLUS_VARIABLESET.
NOTE: The data set WORK.VARCLUSMETA has 8 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
15228  proc print data=WORK.VarClusMETA label noobs;
15229  var ROLE LEVEL COUNT;
15230  label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
15231  title9 ' ';
15232  title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
15233  run;
 
NOTE: There were 8 observations read from the data set WORK.VARCLUSMETA.
NOTE: The PROCEDURE PRINT printed page 1.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
15234  title10;
 
15235  %let EMEXCEPTIONSTRING=;
PERFORMANCE  DETAILS
15631  *------------------------------------------------------------*;
15632  * VarClus: Generation of macros and macro variables;
15633  * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
15634  *------------------------------------------------------------*;
 
15635  %let EMEXCEPTIONSTRING=;
15636  *------------------------------------------------------------*;
15637  * TRAIN: VarClus;
15638  *------------------------------------------------------------*;
15639  %let EM_ACTION = TRAIN;
15640  %let syscc = 0;
15641
15642  %macro main;
15643
15644     filename temp catalog 'sashelp.emexpl.variableclustering_macros.source';
15645     %include temp;
15646     filename temp catalog 'sashelp.emexpl.variableclustering_macros2.source';
15647     %include temp;
15648     filename temp;
15649
15650    %SetProperties;
15651
15652     %if %upcase(&EM_ACTION) = CREATE %then %do;
15653         filename temp catalog 'sashelp.emexpl.variableclustering_create.source';
15654         %include temp;
15655         filename temp;
15656         %create;
15657     %end;
15658     %else
15659     %if %upcase(&EM_ACTION) = TRAIN %then %do;
15660          filename temp catalog 'sashelp.emexpl.variableclustering_train.source';
15661             %include temp;
15662             filename temp;
15663             %train;
15664     %end;
15665     %else
15666     %if %upcase(&EM_ACTION) = SCORE %then %do;
15667             filename temp catalog 'sashelp.emexpl.variableclustering_score.source';
15668             %include temp;
15669             filename temp;
15670             %score;
15671     %end;
15672     %else
15673     %if %upcase(&EM_ACTION) = REPORT %then %do;
15674             filename temp catalog 'sashelp.emexpl.variableclustering_report.source';
15675             %include temp;
15676             filename temp;
15677             %report;
15678     %end;
15679     /*
15680     %if %upcase(&EM_ACTION) = OPENTESTTABLE %then %do;
15681         %put 'OPENING TABLE';
15682     %end;
15683     %if %upcase(&EM_ACTION) = CLOSETESTTABLE %then %do;
15684         %put 'CLOSE TABLE';
15685     %end;
15686     */
15687  %mend main;
15688  %main;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS.SOURCE.
15689 +
15690 +/* Initialize property macro variables */
15691 +%macro SetProperties;
15692 +   %em_checkmacro(name=EM_PROPERTY_MAXCLUS,       global=Y, value=DEFAULT);
15693 +   %em_checkmacro(name=EM_PROPERTY_HIDEVARIABLE,  global=Y, value=Y);
15694 +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,   global=Y, value=SHORT);
15695 +   %em_checkmacro(name=EM_PROPERTY_CLUSSOURCE,    global=Y, value=CORR);
15696 +   %em_checkmacro(name=EM_PROPERTY_CLUSCOMP,      global=Y, value=PRINCIPAL);
15697 +   %em_checkmacro(name=EM_PROPERTY_CLUSHIERACHY,      global=Y, value=Y);
15698 +   %em_checkmacro(name=EM_PROPERTY_INCLUDECLASSVAR,      global=Y, value=N);
15699 +   %em_checkmacro(name=EM_PROPERTY_EXPORTEDCOMP,      global=Y, value=CLUSTERCOMP);
15700 +   %em_checkmacro(name=EM_PROPERTY_MAXEIGEN,         global=Y, value=DEFAULT);
15701 +   %em_checkmacro(name=EM_PROPERTY_PROPORTION,      global=Y, value=DEFAULT);
15702 +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,      global=Y, value=SHORT);
15703 +   %em_checkmacro(name=EM_PROPERTY_TWOSTAGECLUS,      global=Y, value=AUTO);
15704 +   %em_checkmacro(name=EM_PROPERTY_SUPPRESSSAMPWARN,      global=Y, value=N);
15705 +
15706 +%mend SetProperties;
15707 +
15708 +%Macro MakeDummyVariables(indata=,
15709 +                          outvar=,
15710 +                          outdata=,
15711 +                          fileref=,
15712 +                          recreatecmeta=N, /* optional */
15713 +                          incmeta=,     /* optional */
15714 +                          outcmeta=,    /* optional */
15715 +                          ndummyvars=_ndummyvars
15716 +                          );
15717 +    %global &ndummyvars;
15718 +
15719 +    proc dmdb batch data=&indata out=_dmdbdat dmdbcat=_dmdbcat classout=_classout;;
15720 +       class
15721 +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
15722 +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
15723 +    ;
15724 +    run;
15725 +    %let &ndummyvars = 0;
15726 +    data _null_;
15727 +    %let dsid = %sysfunc(open(work._classout));
15728 +      %let &ndummyvars = %sysfunc(attrn(&dsid, NOBS));
15729 +    %let dsid = %sysfunc(close(&dsid));
15730 +    run;
15731 +
15732 +    proc dmzip data=_dmdbdat dmdbcat=_dmdbcat;
15733 +       input
15734 +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
15735 +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
15736 +        / level=nominal stdize=no;
15737 +       make outvar = &outvar;
15738 +       score data = &indata out =&outdata;
15739 +       code  file=  "&fileref";
15740 +    run;
15741 +    %if &recreatecmeta eq Y %then %do;
15742 +    proc contents data =&outvar out=_tmpds(keep=NAME LABEL);
15743 +    data _tmpds;
15744 +        set _tmpds;
15745 +           ROLE = 'INPUT';
15746 +           LEVEL = 'INTERVAL';
15747 +           CREATOR='DMZIP';
15748 +           if NAME = '_TYPE_' then delete;
15749 +    run;
15750 +    data &outcmeta;
15751 +         set &incmeta _tmpds;
15752 +    run;
15753 +    %end;
15754 +    proc datasets lib=work nolist;
15755 +      delete  _dmdbdat _dmdbcat _classout
15756 +    %if &recreatecmeta eq Y %then %do;
15757 +    _tmpds
15758 +    %end;
15759 +    ;
15760 +    quit;
15761 +%Mend MakeDummyVariables;
15762 +
15763 +/*--- Determine Optimal Number of Cluster ----
15764 +%macro FindClusNum(statds=, groupds=, minvariation=);
15765 +   %global optnclus;
15766 +   data varclus_tmp(drop=_NAME_);
15767 +      set &statDs;
15768 +      where _type_ ='PROPOR';
15769 +   run;
15770 +   proc sort data=varclus_tmp;
15771 +      by _NCL_;
15772 +   run;
15773 +   proc transpose data=varclus_tmp out=varclus_tmp;
15774 +      by _NCL_;
15775 +      var %EM_INTERVAL_INPUT
15776 +      %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
15777 +      %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
15778 +      %let nvar = %sysfunc(attrn(&dsid, NVAR));
15779 +          %do i = 2 %to &nvar;
15780 +          %let varname = %sysfunc(varname(&dsid, &i));
15781 +          &varname
15782 +          %end;
15783 +      %end;
15784 +   ;
15785 +   run;
15786 +
15787 +   %if &minVariation eq %then %do;
15788 +       %let minVariation = &EM_PROPERTY_MINVARIATION;
15789 +   %end;
15790 +   %if ^(0<&minVariation<100) %then %do;
15791 +       %let minVariation = 90;
15792 +   %end;
15793 +
15794 +   data _null_;
15795 +      set varclus_tmp end=eof;
15796 +      by _NCL_;
15797 +      retain flag 0;
15798 +      if first._ncl_ then flag=0;
15799 +      if .<col1 < &minVariation then flag=1;
15800 +      if last._ncl_ and ^flag then do;
15801 +         call symput('OPTNCL', _ncl_);
15802 +         stop;
15803 +      end;
15804 +     if eof then call symput('OPTNCL', _ncl_);
15805 +   run;
15806 +
15807 +   %let optnclus = &OPTNCL;
15808 +
15809 +   data varclus_tmp(drop=_NCL_ _NAME_);
15810 +      set &statDs;
15811 +      where _type_ in('RSQUARED' 'GROUP') and _NCL_=&OPTNCL;
15812 +   run;
15813 +   proc sort data=varclus_tmp;
15814 +      by _TYPE_;
15815 +   run;
15816 +   proc transpose data=varclus_tmp out=varclus_tmp;
15817 +      by _TYPE_;
15818 +   run;
15819 +   proc sort data=varclus_tmp;
15820 +      by _name_ _type_;
15821 +   run;
15822 +
15823 +  proc transpose data=varclus_tmp out=&groupds;
15824 +      by _NAME_;
15825 +   run;
15826 +   proc sort data=&groupDs(rename=(col1=Cluster col2=Rsquare _NAME_=VARIABLE));
15827 +      by Cluster descending Rsquare;
15828 +      where Cluster ne 0;
15829 +   run;
15830 +   proc datasets lib=work nolist mt=(DATA VIEW);
15831 +      delete varclus_tmp;
15832 +   run;
15833 +   quit;
15834 +%mend findClusNum;
15835 +*/
15836 +
15837 +%macro getNclusfromTrain(inoutstat=, nc=);
15838 +%global &nc;
15839 +data _null_;
15840 +    set &inoutstat end=eof;
15841 +    if eof then do;
15842 +    call symput("&nc", _ncl_);
15843 +    end;
15844 +run;
15845 +%mend  getNclusfromTrain;
15846 +
15847 +%macro MakeDeltaCode(groupds=, outstatscore=, deltacodefile=);
15848 +
15849 +     *--- Build Code to Modify Metadata ---*;
15850 +     filename X "&deltacodefile";
15851 +     data _null_;
15852 +        FILE X;
15853 +        set &groupds end=eof;
15854 +        /*by Cluster;*/
15855 +         if _N_=1 then do;
15856 +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
15857 +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
15858 +           %end;
15859 +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
15860 +           put "if upcase(strip(NAME)) in (";
15861 +        end;
15862 +        if Strip(upcase(Selected)) eq 'YES' then do;
15863 +           string = '"'!!trim(left(VARIABLE))!!'"';
15864 +           put string;
15865 +        end;
15866 +        if eof then do;
15867 +           put ') then ROLE="INPUT";';
15868 +           put 'else ROLE="REJECTED";';
15869 +           put 'end;';
15870 +
15871 +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
15872 +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
15873 +           %end;
15874 +        end;
15875 +     run;
15876 +     quit;
15877 +
15878 +     filename X;
15879 +
15880 +     quit;
15881 +%mend MakeDeltaCode;
15882 +
15883 +%macro MakeVarClusCorrData(statds=, corrds=, corrplotds= );
15884 +    %if ^%sysfunc(exist(&statds)) %then %do;
15885 +         %goto doendc;
15886 +    %end;
15887 +
15888 +    data &corrds(drop=_TYPE_ _NCL_) ;
15889 +       set &statds;
15890 +       where _type_ eq 'CORR' ;
15891 +    run ;
15892 +    proc sort data=&corrds;
15893 +       by _NAME_ ;
15894 +    run ;
15895 +    proc transpose data=&corrds out=&corrplotds name=_TMP_;
15896 +      BY _NAME_ ;
15897 +    run ;
15898 +    data &corrplotds;
15899 +       length _Y_ $100;
15900 +       set &corrplotDs;
15901 +       if _LABEL_ ne '' then _Y_=_LABEL_ ; else _Y_=_TMP_ ;
15902 +    run ;
15903 +    data varclus_match(rename=(_TMP_= _NAME_ _LABEL_=_X_));
15904 +       set &corrplotds;
15905 +       where _LABEL_ ne '' ;
15906 +       keep _TMP_ _LABEL_ ;
15907 +    run ;
15908 +    data _null_;
15909 +       nobs=0;
15910 +       dsid = open('varclus_match');
15911 +       if dsid then do;
15912 +          nobs = attrn(dsid, 'NOBS');
15913 +          dsid = close(dsid);
15914 +       end;
15915 +       call symput ('CORR_NOBS', nobs);
15916 +    run;
15917 +    %if &corr_nobs %then %do;
15918 +        proc sort data=varclus_match;
15919 +           by _name_;
15920 +        run ;
15921 +        proc sort data=&corrplotds;
15922 +           by _name_;
15923 +        run ;
15924 +        data &corrplotds(keep= _X_ _Y_ col1 rename=(col1=Correlation)) ;
15925 +           merge varclus_match &corrplotds;
15926 +           by _NAME_ ;
15927 +           if _X_ eq '' then _X_=_NAME_ ;
15928 +           label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
15929 +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
15930 +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
15931 +
15932 +       run ;
15933 +    %end;
15934 +    %else %do;
15935 +        proc sort data=&corrplotds;
15936 +           by _name_;
15937 +        run ;
15938 +        data &corrplotds(keep= _NAME_ _Y_ col1 rename=(_NAME_=_X_ col1=Correlation)) ;
15939 +           set &corrplotds;
15940 +           label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
15941 +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
15942 +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
15943 +
15944 +        run ;
15945 +    %end;
15946 +    proc sort data=&corrplotds;
15947 +       by _X_ _Y_;
15948 +    run ;
15949 +    proc datasets lib=work nolist mt=(DATA VIEW);
15950 +       delete varclus_match;
15951 +    run;
15952 +    quit;
15953 +
15954 +%doendc:
15955 +
15956 +%mend MakeVarClusCorrData;
15957 +
15958 +%macro MakeStatPlotData(statds= , outstatplotds=);
15959 +   %if %sysfunc(exist(&statds)) %then %do;
15960 +
15961 +       data varclus_tmp(drop=_NAME_ _NCL_) ;
15962 +          set &statDs;
15963 +          where _type_ in('MEAN', 'STD', 'N');
15964 +       run ;
15965 +       proc transpose data=varclus_tmp out=&outstatplotds;
15966 +          id _TYPE_ ;
15967 +       run ;
15968 +       data &outstatplotds;
15969 +          set &outstatplotds(obs=1000);
15970 +          label _name_= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_name, noquote))";
15971 +          label _label_="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
15972 +          if MEAN ne 0 then SCALEDSTD= STD / MEAN ;
15973 +          else SCALEDSTD= STD ;
15974 +          label SCALEDSTD = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_scaledstd, noquote))";
15975 +       run ;
15976 +       proc sort data=&outstatplotds;
15977 +          by descending SCALEDSTD ;
15978 +       run ;
15979 +       proc datasets lib=work nolist mt=(DATA VIEW);
15980 +          delete varclus_tmp;
15981 +       run;
15982 +       quit;
15983 +    %end;
15984 +
15985 +%mend MakeStatPlotData;
15986 +
15987 +
15988 +%macro CreateScoreCode(indata=, ncluscomp=, fileref=);
15989 +     %EM_GETNAME(KEY=OUTSTATSCORE, type=DATA);
15990 +    data &EM_USER_OUTSTATSCORE;
15991 +          set &indata;
15992 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
15993 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
15994 +          if _TYPE_ = 'STD' then _NAME_='STD';
15995 +          DROP _TYPE_ _NCL_;
15996 +     run;
15997 +
15998 +     filename _file_  "&fileRef";
15999 +
16000 +     data _null_;
16001 +        FILE _file_ MOD;
16002 +        put ' ';
16003 +        put '/*-------------------------------------------------*/';
16004 +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_begin , noquote))" '*/';
16005 +        put '/*-------------------------------------------------*/';
16006 +        put ' ';
16007 +        %let dsid = %sysfunc(open(&EM_USER_OUTSTATSCORE));
16008 +
16009 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
16010 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
16011 +
16012 +        %let k = 1;
16013 +        %do %while(^%sysfunc(fetch(&dsid)));
16014 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
16015 +                %if &k > 2 %then %do;
16016 +                 %let cn = %eval(&k-2);
16017 +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_cluscompnum, noquote, &cn))"  "------ */";
16018 +                %end;
16019 +                %let k = %eval(&k+1);
16020 +        %end;
16021 +
16022 +        %let rc = %sysfunc(rewind(&dsid));
16023 +
16024 +        %do i= 2 %to &nvar;
16025 +            %let _varname =  %sysfunc(varname(&dsid, &i));
16026 +            %do %while(^%sysfunc(fetch(&dsid)));
16027 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
16028 +                %if &_name = MEAN %then
16029 +                %let _mean = %sysfunc(getvarn(&dsid, &i));
16030 +                %else %if &_name = STD %then
16031 +                %let _std = %sysfunc(getvarn(&dsid, &i));
16032 +                %else %do;
16033 +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
16034 +                      %let abscoeff = %sysfunc(abs(&coeff));
16035 +                          %if &abscoeff >  0 %then %do;
16036 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
16037 +                           %end;
16038 +                 %end;
16039 +             %end;
16040 +             %let rc = %sysfunc(rewind(&dsid));
16041 +         %end;
16042 +
16043 +        %let dsid= %sysfunc(close(&dsid));
16044 +       run;
16045 +%mend CreateScoreCode;
16046 +
16047 +
16048 +
16049 +/*----------------------------------------------------------
16050 +    Instead of using %MakeRSquareData,
16051 +    %MakeVarClusResultTable at macro2.source is used
16052 + +----------------------------------------------------------*/
16053 +
16054 +
16055 +%macro MakeRSquareData(indata=, inClusRSquare=, outdata=, ncluster=);
16056 +
16057 +/* modifying  from ods rsquare = data */
16058 +
16059 +data &outdata(drop= ControlVar  NumberOfClusters CurrentCluster);
16060 +    Length Cluster $16;
16061 +    length Variable $32;
16062 +    Length VariableLabel $64;
16063 +    set &indata; retain CurrentCluster;
16064 +    if NumberOfClusters ^= &ncluster then delete;
16065 +    if strip(Cluster) eq '' then Cluster = CurrentCluster;
16066 +    CurrentCluster = Cluster;
16067 +   run;
16068 +proc sort data =&outdata ;
16069 +     by Cluster RsquareRatio;
16070 +run;
16071 +data _tmprsq(drop=index);
16072 +     set &outdata; by Cluster;
16073 +     if first.Cluster then do;
16074 +     index = strip(scan(Cluster,2 ));
16075 +     Variable = "Clus"||index;
16076 +     VariableLabel = "Cluster Component "||index;
16077 +     OwnCluster = 1;
16078 +     NextClosest = .;
16079 +     RsquareRatio = 0;
16080 +     output;
16081 +     end;
16082 +run;
16083 +
16084 +proc sort data = _tmprsq ;
16085 +     by Cluster RsquareRatio;
16086 +run;
16087 +data &outdata;
16088 +     set &outdata _tmprsq;
16089 +by Cluster;
16090 +run;
16091 +
16092 +
16093 +/* Just create the Selected variable with all YES */
16094 +
16095 +data &outdata;
16096 +    set &outdata; by cluster;
16097 +    length Selected $8;
16098 +    Selected = 'YES';
16099 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
16100 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
16101 +    rename OwnCluster = RSqWithClusterComp;
16102 +    rename NextClosest = RSqWithNextClusComp;
16103 +run;
16104 +
16105 +
16106 +/* Selected = Y/N will be done %score section -----
16107 +
16108 +%if &EM_PROPERTY_EXPORTEDCOMP ne CLUSTERCOMP %then %do;
16109 +data &outdata;
16110 +    set &outdata; by cluster;
16111 +    length Selected $8;
16112 +    if first.Cluster then Selected = 'YES';
16113 +    else Selected = 'NO';
16114 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
16115 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
16116 +    rename OwnCluster = RSqWithClusterComp;
16117 +    rename NextClosest = RSqWithNextClusComp;
16118 +run;
16119 +%end;
16120 +%else %do;
16121 +data &outdata;
16122 +    set &outdata; by cluster;
16123 +    if last.Cluster then Selected = 'YES';
16124 +    else Selected = 'NO';
16125 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
16126 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
16127 +    rename OwnCluster = RSqWithClusterComp;
16128 +    rename NextClosest = RSqWithNextClusComp;
16129 +run;
16130 +%end;
16131 +---------------------------------------------------------------*/
16132 +
16133 +%if %sysfunc(exist(&inClusRSquare)) %then %do;
16134 +/* to calculate NextClosestClusRsq */
16135 +proc transpose data = &inClusRSquare  out=_clusRsq;
16136 +      by cluster;
16137 +      run;
16138 +data _clusRsq;
16139 +     set _clusRsq;
16140 +     if strip(upcase(Cluster)) eq strip(upcase(_NAME_)) then delete;
16141 +run;
16142 +
16143 +proc sort data=_clusRsq;
16144 +    by cluster col1;
16145 +    run;
16146 +data _clusRsq(drop=_NAME_ _LABEL_);
16147 +     set _clusRsq; by cluster;
16148 +     if last.Cluster then output;
16149 +     label  COL1 = 'R-Sqaure with Next Cluster Component';
16150 +     rename COL1 = RSqWithNextClusComp;
16151 +     rename Cluster = Variable;
16152 +     label  Cluster = "Variable";
16153 +run;
16154 +
16155 +proc sort data =&outdata;
16156 +     by Variable;
16157 +run;
16158 +data &outdata;
16159 +    merge &outdata _clusRsq;
16160 +    by Variable;
16161 +run;
16162 +proc sort data =&outdata;
16163 +by Cluster  RsquareRatio;
16164 +run;
16165 +quit;
16166 +%end;
16167 +
16168 +proc datasets lib = work nolist;
16169 +     delete _tmprsq _clusRsq;
16170 +     run;
16171 +quit;
16172 +
16173 +%mend MakeRSquareData;
16174 +
16175 +
16176 +/*-------------------------------------------------------------------------*/
16177 +
16178 +
16179 +
16180 +%macro ModifyCorr(indata=,
16181 +                  outdata=,
16182 +                  rsquare = Y
16183 +                  );
16184 +    data corr_tmp;
16185 +        set &indata;
16186 +    run;
16187 +     proc sql;
16188 +           update &indata
16189 +           set
16190 +     %let dsid = %sysfunc(open(work.corr_tmp));
16191 +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
16192 +          %do i = 4 %to &nvar;
16193 +          %let _name = %sysfunc(varname(&dsid, &i));
16194 +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
16195 +            %else  %let _name_md = &_name;
16196 +            %if &i < &nvar %then %do;
16197 +               &_name = 1- &_name_md ,
16198 +            %end;
16199 +            %else %do;
16200 +               &_name = &_name_md where _TYPE_ contains 'CORR' ;
16201 +            %end;
16202 +          %end;
16203 +      %let dsid= %sysfunc(close(&dsid));
16204 +
16205 +      select * from &indata;
16206 +      run;
16207 +      proc datasets lib = work nolist;
16208 +           delete corr_tmp;
16209 +      run;
16210 +      quit;
16211 +
16212 + %mend ModifyCorr;
16213 +
16214 + %macro MakeClusStructCorrData(indata=,outdata=, ncluster=, Rsquare=N);
16215 +    data &outdata(drop= _NCL_  _TYPE_);
16216 +       set &indata;
16217 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
16218 +       rename _NAME_ = Cluster;
16219 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
16220 +    run;
16221 +    %if &RSquare eq Y %then %do;
16222 +     data corr_tmp;
16223 +        set &outdata;
16224 +     run;
16225 +
16226 +     data &outdata(drop=i);
16227 +          set &outdata;
16228 +          %let dsid = %sysfunc(open(work.corr_tmp));
16229 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
16230 +          %do i = 2 %to &nvar;
16231 +            %let _name = %sysfunc(varname(&dsid, &i));
16232 +            %let _name_md = &_name.**2;
16233 +                &_name = &_name_md;
16234 +          %end;
16235 +      %let dsid= %sysfunc(close(&dsid));
16236 +      run;
16237 +      proc datasets lib = work nolist;
16238 +           delete corr_tmp;
16239 +      run;
16240 +
16241 +    %end;
16242 +     quit;
16243 +%mend MakeClusStructCorrData;
16244 +
16245 +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, RSquare=N, makeplotds=N, plotds=);
16246 +    data &outdata(drop= _NCL_  _TYPE_);
16247 +       set &indata;
16248 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
16249 +       rename _NAME_ = Cluster;
16250 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
16251 +    run;
16252 +    data corr_tmp;
16253 +        set &outdata;
16254 +    run;
16255 +
16256 +    %let dsid = %sysfunc(open(work.corr_tmp));
16257 +    %let nclus2= %eval(&ncluster+1);
16258 +    data &outdata;
16259 +         set &outdata;
16260 +          %do i = 2 %to &nclus2;
16261 +          %let i_1 = %eval(&i-1);
16262 +            %let _name = %sysfunc(varname(&dsid, &i));
16263 +            %let _newName = Clus&i_1;
16264 +                rename &_name = &_newName; ;
16265 +                *label &_name ="Cluster &i_1";
16266 +                label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
16267 +          %end;
16268 +          keep Cluster
16269 +          %do i = 2 %to &nclus2;
16270 +                %let _name = %sysfunc(varname(&dsid, &i));
16271 +                &_name
16272 +          %end;
16273 +          ;
16274 +    %let dsid= %sysfunc(close(&dsid));
16275 +     run;
16276 +     quit;
16277 +
16278 +    %if &RSquare eq Y %then %do;
16279 +
16280 +       data corr_tmp;
16281 +        set &outdata;
16282 +     run;
16283 +
16284 +     data &outdata(drop=i);
16285 +          set &outdata;
16286 +          %let dsid = %sysfunc(open(work.corr_tmp));
16287 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
16288 +          %do i = 2 %to &nvar;
16289 +            %let _name = %sysfunc(varname(&dsid, &i));
16290 +            %let _name_md = &_name.**2;
16291 +                &_name = &_name_md;
16292 +          %end;
16293 +      %let dsid= %sysfunc(close(&dsid));
16294 +      run;
16295 +    %end;
16296 +
16297 +    %if &makeplotds eq Y %then %do;
16298 +     proc transpose data = &outdata
16299 +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
16300 +          by cluster;
16301 +     run;
16302 +     data &plotds;
16303 +          set  &plotds;
16304 +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
16305 +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
16306 +     run;
16307 +     %end;
16308 +     proc datasets lib = work nolist;
16309 +           delete corr_tmp;
16310 +     run;
16311 +     quit;
16312 +%mend MakeInterClusCorrData;
16313 +
16314 +
16315 +%macro MakeClusConstellData(indata=, outlink=, outnode=);
16316 +
16317 +data &outlink(drop = Selected);
16318 +     set &indata;
16319 +     LINKID = _N_;
16320 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
16321 +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
16322 +run;
16323 +data &outnode(keep=NODEID TYPE LABEL);
16324 +    set &indata;
16325 +    length TYPE $16;
16326 +    rename Variable = NODEID;
16327 +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
16328 +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
16329 +    then  TYPE = "CLUSTER";
16330 +    else  TYPE="VARIABLE";
16331 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
16332 +run;
16333 +quit;
16334 +%mend MakeClusConstellData;
16335 +
16336 +
16337 +
16338 +%macro MakeClusConstellData(indata=, outlink=, outnode=);
16339 +
16340 +data &outlink(drop = Selected);
16341 +     set &indata;
16342 +     LINKID = _N_;
16343 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
16344 +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
16345 +run;
16346 +data &outnode(keep=NODEID TYPE LABEL);
16347 +    set &indata;
16348 +    length TYPE $16;
16349 +    rename Variable = NODEID;
16350 +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
16351 +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
16352 +    then  TYPE = "CLUSTER";
16353 +    else  TYPE="VARIABLE";
16354 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
16355 +run;
16356 +quit;
16357 +%mend MakeClusConstellData;
16358 +
16359 +
16360 +/*--- This will work only when inds is not a view data -------
16361 +
16362 +%macro getNVarNObs(inds=, nvar=, nobs=);
16363 +
16364 +    %global &nvar;
16365 +    %global &nobs;
16366 +    data _null_;
16367 +         dsid = open("&inds");
16368 +         nv = attrn(dsid, 'NVAR');
16369 +         no = attrn(dsid, 'NOBS');
16370 +         dsid = close(dsid);
16371 +         call symput("&nvar", nv);
16372 +         call symput("&nobs", no);
16373 +    run;
16374 +    quit;
16375 +%mend  getNVarNObs;
16376 +
16377 ++---------------------------------------------------------------*/
16378 +
16379 +
16380 +%macro getNVar(inds=, nvar=);
16381 +    %global &nvar;
16382 +    data _null_;
16383 +         dsid = open("&inds");
16384 +         nv = attrn(dsid, 'NVAR');
16385 +         dsid = close(dsid);
16386 +         call symput("&nvar", nv);
16387 +    run;
16388 +    quit;
16389 +%mend  getNVar;
16390 +
16391 +
16392 +
16393 +%macro getNObs(inds=, nobs=);
16394 +    %global &nobs;
16395 +    data _null_;
16396 +        set &inds end=eof;
16397 +        if eof then call symput("&nobs", _N_);
16398 +    run;
16399 +    quit;
16400 +%mend  getNObs;
16401 +
16402 +%Macro CreateVarclusMeta(trainnum=);
16403 +   %EM_GETNAME(KEY=VARCLUSMETA, TYPE=DATA);
16404 +    data &EM_USER_VARCLUSMETA;
16405 +         length TrainNum 8.;
16406 +         length NewTrain $8;
16407 +         length NGCluster 8.;
16408 +         length ExportedComp $16;
16409 +         length HideVariable $8;
16410 +         TrainNum = &trainnum;
16411 +         NewTrain = "Y";
16412 +         ExportedComp = "&EM_PROPERTY_EXPORTEDCOMP";
16413 +         HideVariable = "&EM_PROPERTY_HIDEVARIABLE";
16414 +         NGCluster = 0; /* zero means no twostage */
16415 +   run;
16416 +   quit;
16417 +%mend CreateVarclusMeta;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS2.SOURCE.
16418 +
16419 +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, globalclusid=, RSquare=N, makeplotds=N, plotds=);
16420 +    data &outdata(drop= _NCL_  _TYPE_);
16421 +       set &indata;
16422 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
16423 +       %if &globalclusid ne %then %do;
16424 +       _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
16425 +       rename _NAME_ = Cluster;
16426 +       %end;
16427 +       %else %do;
16428 +        _NAME_ = upcase(_NAME_);
16429 +       rename _NAME_ = Cluster;
16430 +       %end;
16431 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
16432 +    run;
16433 +    data corr_tmp;
16434 +        set &outdata;
16435 +    run;
16436 +
16437 +    %let dsid = %sysfunc(open(work.corr_tmp));
16438 +    %let nclus2= %eval(&ncluster+1);
16439 +    data &outdata;
16440 +         set &outdata;
16441 +          %do i = 2 %to &nclus2;
16442 +          %let i_1 = %eval(&i-1);
16443 +            %let _name = %sysfunc(varname(&dsid, &i));
16444 +            %if &globalclusid ne %then
16445 +                %do; %let _newName = GC&globalclusid._CLUS&i_1;
16446 +                     rename &_name = &_newName;
16447 +                     *label &_name ="GC &globalclusid : Cluster &i_1";
16448 +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gc_clusternum, noquote,  &globalclusid, &i_1))";
16449 +                %end;
16450 +            %else
16451 +                %do; %let _newName = CLUS&i_1;
16452 +                     rename &_name = &_newName;
16453 +                     *label &_name ="Cluster &i_1";
16454 +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
16455 +                %end;
16456 +          %end;
16457 +          keep Cluster
16458 +          %do i = 2 %to &nclus2;
16459 +                %let _name = %sysfunc(varname(&dsid, &i));
16460 +                &_name
16461 +          %end;
16462 +          ;
16463 +    %let dsid= %sysfunc(close(&dsid));
16464 +     run;
16465 +     quit;
16466 +
16467 +    %if &RSquare eq Y %then %do;
16468 +
16469 +       data corr_tmp;
16470 +        set &outdata;
16471 +     run;
16472 +
16473 +     data &outdata;
16474 +          set &outdata;
16475 +          %let dsid = %sysfunc(open(work.corr_tmp));
16476 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
16477 +          %do i = 2 %to &nvar;
16478 +            %let _name = %sysfunc(varname(&dsid, &i));
16479 +            %let _name_md = &_name.**2;
16480 +                &_name = &_name_md;
16481 +          %end;
16482 +      %let dsid= %sysfunc(close(&dsid));
16483 +      run;
16484 +    %end;
16485 +
16486 +    %if &makeplotds eq Y %then %do;
16487 +     proc transpose data = &outdata
16488 +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
16489 +          by cluster;
16490 +     run;
16491 +     data &plotds;
16492 +          set  &plotds;
16493 +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
16494 +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
16495 +          label  Correlation="%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
16496 +     run;
16497 +     %end;
16498 +     proc datasets lib = work nolist;
16499 +           delete corr_tmp;
16500 +     run;
16501 +     quit;
16502 +%mend MakeInterClusCorrData;
16503 +
16504 +%macro MakeOwnRSquare(indata=, outdata=, ncluster=, globalclusid=);
16505 +    data _tmpds(drop= _NCL_);
16506 +       set &indata;
16507 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) in ('GROUP','RSQUARED')) then delete;
16508 +       %if &globalclusid ne %then %do;
16509 +           _NAME_ = "GC&globalclusid.";
16510 +       rename _NAME_ = Cluster;
16511 +       %end;
16512 +       %else %do;
16513 +        _NAME_ = "CLUS";
16514 +        rename _NAME_ = Cluster;
16515 +       %end;
16516 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
16517 +    run;
16518 +    proc transpose data =_tmpds out =&outdata;
16519 +    run;
16520 +
16521 +    data &outdata(drop=COL1);
16522 +        %if &globalclusid ne %then %do;
16523 +        length GCluster $16;
16524 +        %end;
16525 +        length Cluster $32;
16526 +        length _NAME_ $32;
16527 +         set &outdata;
16528 +         _NAME_ = upcase(_NAME_);
16529 +         rename _NAME_=Variable;
16530 +         *label _NAME_="Variable";
16531 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
16532 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
16533 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
16534 +
16535 +         %if &globalclusid ne %then %do;
16536 +          GCluster = "GC&globalclusid";
16537 +          Cluster = "GC&globalclusid._CLUS"||strip(COL1);
16538 +         %end;
16539 +         %else %do;
16540 +         Cluster = "CLUS"||strip(COL1);
16541 +        %end;
16542 +         rename COL2 = RSqWithOwnClusComp;
16543 +         *label COL2 = "R-Square With Own Cluster Component";
16544 +         label COL2 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
16545 +
16546 +   run;
16547 +   proc sort data =&outdata;
16548 +        by Cluster RSqWithOwnClusComp;
16549 +   run;
16550 +   proc datasets lib = work nolist;
16551 +           delete _tmpds;
16552 +   run;
16553 +   quit;
16554 +%mend MakeOwnRSquare;
16555 +
16556 +%macro MakeClusStructCorrData(indata=, outdata=, globalclusid=, ncluster=, Rsquare=N);
16557 +    data &outdata(drop= _NCL_  _TYPE_);
16558 +       %if &globalclusid ne %then %do;
16559 +        length GCluster $16;
16560 +        %end;
16561 +       set &indata;
16562 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
16563 +       %if &globalclusid ne %then %do;
16564 +         GCluster = "GC&globalclusid";
16565 +         _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
16566 +         rename _NAME_ = Cluster;
16567 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
16568 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
16569 +
16570 +       %end;
16571 +       %else %do;
16572 +         _NAME_ = upcase(_NAME_);
16573 +         rename _NAME_ = Cluster;
16574 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
16575 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
16576 +
16577 +       %end;
16578 +     run;
16579 +    %if &RSquare eq Y %then %do;
16580 +     data corr_tmp;
16581 +          set &outdata;
16582 +     run;
16583 +     %let istart = 2;
16584 +     %if &globalclusid ne %then %let istart = 3;
16585 +     data &outdata;
16586 +          set &outdata;
16587 +          %let dsid = %sysfunc(open(work.corr_tmp));
16588 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
16589 +          %do i =&istart %to &nvar;
16590 +            %let _name = %sysfunc(varname(&dsid, &i));
16591 +            %let _name_md = &_name.**2;
16592 +                &_name = &_name_md;
16593 +          %end;
16594 +      %let dsid= %sysfunc(close(&dsid));
16595 +      run;
16596 +      proc datasets lib = work nolist;
16597 +           delete corr_tmp;
16598 +      run;
16599 +    %end;
16600 +     quit;
16601 +%mend MakeClusStructCorrData;
16602 +
16603 +/*
16604 +%MakeClusStructCorrData(indata=playpen._outstat, outdata=_structrsq , ncluster=7, Rsquare=Y);
16605 +*/
16606 +
16607 +%macro FindNextClosestClusByVar(indata=, outdata=, globalclusid=, ncluster=);
16608 +
16609 +     /* The indata should be the outdata
16610 +        from %MakeClusStructCorrData(indata=, outdata=, ); */
16611 +
16612 +     proc sort data =&indata out=_tmpclusRsq;
16613 +     by cluster;
16614 +     run;
16615 +
16616 +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
16617 +      by cluster;
16618 +     run;
16619 +
16620 +     proc sort data=_tmpclusRsq;
16621 +        by _NAME_ COL1;
16622 +     run;
16623 +
16624 +     data _tmpclusRsq;
16625 +         length _NAME_ $32;
16626 +         set _tmpclusRsq; by _NAME_;
16627 +          _NAME_ = upcase(_NAME_);
16628 +          %if &ncluster ne 1 %then %do;
16629 +             if last._NAME_ then delete;
16630 +          %end;
16631 +          %else %do;
16632 +             COL1 = 0;
16633 +          %end;
16634 +     run;
16635 +     /* need to sort again */
16636 +     proc sort data=_tmpclusRsq;
16637 +        by _NAME_ COL1;
16638 +     run;
16639 +
16640 +     data &outdata;
16641 +         set _tmpclusRsq; by _NAME_;
16642 +         Cluster = upcase(Cluster);
16643 +         if last._NAME_ then output;
16644 +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
16645 +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
16646 +         rename COL1 = RSqWithNextClusComp;
16647 +         Cluster = upcase(Cluster);
16648 +         rename Cluster = ClosestCluster;
16649 +         *label  Cluster = "Next Closest Cluster";
16650 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
16651 +         rename _NAME_ = Variable;
16652 +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
16653 +    run;
16654 +
16655 +
16656 +    %if &globalclusid ne %then %do;
16657 +    data &outdata;
16658 +       length GCluster $16;
16659 +       set &outdata;
16660 +       GCluster = "GC&globalclusid";
16661 +       run;
16662 +    %end;
16663 +    proc datasets lib = work nolist;
16664 +           delete _tmpclusRsq;
16665 +    run;
16666 +    quit;
16667 +%mend FindNextClosestClusByVar;
16668 +
16669 +
16670 +%macro FindNextClosestClusByCluster(indata=, outdata=, globalclusid=, ncluster=);
16671 +     /* The indata should be the outdata from %MakeInterClusCorrData(indata=, outdata=, ); */
16672 +     proc sort data =&indata out=_tmpclusRsq;
16673 +     by cluster;
16674 +     run;
16675 +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
16676 +     by cluster;
16677 +     run;
16678 +     proc sort data=_tmpclusRsq;
16679 +        by _NAME_ col1;
16680 +     run;
16681 +     data _tmpclusRsq;
16682 +         length _NAME_ $32;
16683 +         set _tmpclusRsq; by _NAME_;
16684 +          _NAME_ = upcase(_NAME_);
16685 +          %if &ncluster ne 1 %then %do;
16686 +             if last._NAME_ then delete;
16687 +          %end;
16688 +          %else %do;
16689 +             COL1 = 0;
16690 +          %end;
16691 +     run;
16692 +     data &outdata;
16693 +         set _tmpclusRsq; by _NAME_;
16694 +         Cluster = upcase(Cluster);
16695 +         if last._NAME_ then output;
16696 +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
16697 +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
16698 +         rename COL1 = RSqWithNextClusComp;
16699 +         Cluster = upcase(Cluster);
16700 +         rename Cluster = ClosestCluster;
16701 +         *label  Cluster = "Next Closest Cluster";
16702 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
16703 +         rename _NAME_ = Variable;
16704 +         *label  _NAME_ = "Variable";
16705 +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
16706 +
16707 +    run;
16708 +    %if &globalclusid ne %then %do;
16709 +    data &outdata;
16710 +       length GCluster $16;
16711 +       set &outdata;
16712 +       GCluster = "GC&globalclusid";
16713 +       run;
16714 +    %end;
16715 +
16716 +    proc datasets lib = work nolist;
16717 +           delete _tmpclusRsq;
16718 +    run;
16719 +
16720 +    quit;
16721 +%mend FindNextClosestClusByCluster;
16722 +
16723 +%macro MakeVarClusResultTable(indata1=, indata2=, indata3=, outdata=, globalclusid=, ncluster=, selectedcomp=clustercomp);
16724 +/*----
16725 +  indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq,
16726 +-----------*/
16727 +
16728 +proc sort data =&indata1;
16729 +    by Variable;
16730 +run;
16731 +proc sort data =&indata2;
16732 +    by Variable;
16733 +run;
16734 +data &outdata;
16735 +    merge &indata1 &indata2;
16736 +    by Variable;
16737 +    length Type $16;
16738 +    Type = 'Variable';
16739 +    *label Type ='Type';
16740 +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
16741 +run;
16742 +
16743 +
16744 +data &indata3;
16745 +    set  &indata3 ;
16746 +    length RSqWithOwnClusComp 8.;
16747 +    Cluster = Variable;
16748 +    RSqWithOwnClusComp = 1;
16749 +    *label RSqWithOwnClusComp = "R-Square With Own Cluster Component";
16750 +    label RSqWithOwnClusComp = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
16751 +    length Type $16;
16752 +    Type = 'ClusterComp';
16753 +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
16754 +
16755 +;
16756 +run;
16757 +
16758 +proc sort data=&outdata;
16759 +    by Cluster;
16760 +run;
16761 +proc sort data =&indata3;
16762 +    by Cluster;
16763 +run;
16764 +
16765 +data &outdata;
16766 +     set &outdata &indata3;
16767 +     by Cluster;
16768 +run;
16769 +
16770 +
16771 +/* Create the Selected variable with all YES */
16772 +
16773 +data &outdata;
16774 +     set &outdata;
16775 +     length RsqRatio 8.;
16776 +     length Selected $8;
16777 +     *label RSqRatio = "1-R**2 Ratio";
16778 +     label RSqRatio =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_oneminusrsq, noquote))" ;
16779 +     *label Selected = "Variable Selected";
16780 +     label Selected = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_varselected, noquote))" ;
16781 +     RsqRatio = (1-RSqWithOwnClusComp)/(1-RSqWithNextClusComp);
16782 +     Selected ='YES';
16783 +     rename _LABEL_ = Label;
16784 +     label _LABEL_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
16785 +run;
16786 +
16787 +
16788 +/*----  Selected = Y/N will be assigened at the %score                   -------+
16789 +        Just create the Selected variable with all YES at the step above
16790 + +------------------------------------------------------------------------------+
16791 +
16792 +proc sort data=&outdata;
16793 +    by Cluster RsqRatio;
16794 +run;
16795 +
16796 +%if &selectedcomp eq CLUSTERCOMP %then %do;
16797 +data &outdata;
16798 +     set &outdata; by Cluster;
16799 +     length Selected $8;
16800 +     label Selected = "Variable Selected";
16801 +     if  first.Cluster then Selected ='Yes';
16802 +     else Selected = 'No';
16803 +    run;
16804 +%end;
16805 +%else %do;
16806 +data &outdata(drop = _var _varchange);
16807 +     set &outdata; retain _var 0; by Cluster;
16808 +     length Selected $8;
16809 +     label Selected = "Variable Selected";
16810 +     if first.Cluster then  _varchange = 0;
16811 +     else _varchange =1;
16812 +     if _var ne _varchange then  Selected  = 'Yes';
16813 +     else Selected = 'No';
16814 +     if last.cluster then  _var = 0;
16815 +     else _var = _varchange;
16816 +run;
16817 +%end;
16818 +
16819 +--------------------------------------------------------------*/
16820 +
16821 +quit;
16822 +%mend MakeVarClusResultTable;
16823 +
16824 +%Macro MakePlotDataFromCorrTable(indata=, outdata=, globalclusid=);
16825 +     proc sort data =&indata;
16826 +        by cluster;
16827 +     run;
16828 +     proc transpose data =&indata
16829 +          out=&outdata(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
16830 +          by cluster;
16831 +     run;
16832 +     data &outdata;
16833 +          set  &outdata;
16834 +          label x= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
16835 +          label Y= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
16836 +          label Correlation = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))" ;
16837 +     run;
16838 +     %if &globalclusid ne %then %do;
16839 +     data &outdata;
16840 +          Length GCluster $16;
16841 +          label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
16842 +          set  &outdata;
16843 +          GCluster ="GC&globalclusid.";
16844 +          run;
16845 +     %end;
16846 +
16847 +%Mend MakePlotDataFromCorrTable;
16848 +
16849 +
16850 +%macro MakeCorrelation(indata=,
16851 +                       outstat=_tmpoutstat,
16852 +                       corrmatrix=N,
16853 +                       outcorr=_tmpoutcorr,
16854 +                       includeclassvar=N,
16855 +                       target=,
16856 +                       freq=,
16857 +                       weight=);
16858 +   %if &target eq  %then %do;
16859 +
16860 +       proc varclus data=&indata outstat=&outstat hi maxclusters=1 noprint;
16861 +            var %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED
16862 +       %if &includeclassvar eq Y %then %do;
16863 +          %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
16864 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
16865 +          %do i = 2 %to &nvar;
16866 +          %let varname = %sysfunc(varname(&dsid, &i));
16867 +          &varname
16868 +          %end;
16869 +       %end;
16870 +       ;
16871 +      %if &freq ne  %then %do;
16872 +          freq &freq;
16873 +      %end;
16874 +      %if &weight ne  %then %do;
16875 +          weight &weight;
16876 +      %end;
16877 +
16878 +      run;
16879 +      %if &corrmatrix eq Y %then %do;
16880 +      data  &outcorr (drop = _NCL_ _TYPE_);
16881 +           set  &outstat ;
16882 +           if _TYPE_ ='CORR' then output;
16883 +      run;
16884 +      %end;
16885 +    %end;
16886 +    %else %do;
16887 +       proc corr data=&indata outp=&outstat noprint;
16888 +            var
16889 +       %let dsid = %sysfunc(open(&indata));
16890 +       %let nvar = %sysfunc(attrn(&dsid, NVAR));
16891 +          %do i = 1 %to &nvar;
16892 +              %let _name = %sysfunc(varname(&dsid, &i));
16893 +              %if &_name ne &target %then;
16894 +              &_name
16895 +           %end;
16896 +        %let dsid= %sysfunc(close(&dsid));
16897 +        ;
16898 +        with &target;
16899 +        run;
16900 +    %end;
16901 +    quit;
16902 +%mend MakeCorrelation;
16903 +
16904 +
16905 +%macro MakeCorrelationDistance(indata=,
16906 +                               outdata=,
16907 +                               rsquare = N
16908 +                               );
16909 +    data corr_tmp;
16910 +        set &indata;
16911 +        if _N_ = 1 then do;
16912 +           output;
16913 +           stop;
16914 +         end;
16915 +    run;
16916 +    %if &outdata ne  %then %let  _outdata = &outdata;
16917 +    %else %let _outdata = &indata;
16918 +
16919 +    data &_outdata;
16920 +         set &indata;
16921 +
16922 +         %let dsid = %sysfunc(open(work.corr_tmp));
16923 +         %let nvar = %sysfunc(attrn(&dsid, NVAR));
16924 +          %do i = 2 %to &nvar;
16925 +              %let _name = %sysfunc(varname(&dsid, &i));
16926 +              %if &rsquare eq Y %then %let _name_md = &_name.**2;
16927 +              %else  %let _name_md = &_name;
16928 +              &_name = 1- &_name_md;
16929 +          %end;
16930 +      %let dsid= %sysfunc(close(&dsid));
16931 +      run;
16932 +      proc datasets lib = work nolist;
16933 +           delete corr_tmp;
16934 +      run;
16935 +      quit;
16936 +  %mend MakeCorrelationDistance;
16937 +
16938 +
16939 +%macro UpdateOutStatCorrToDistance(indata=, /* indata should be a outstat from proc varclus */
16940 +                                   rsquare = N
16941 +                                   );
16942 +    data corr_tmp;
16943 +        set &indata;
16944 +    run;
16945 +    proc sql noprint;
16946 +           update &indata
16947 +           set
16948 +     %let dsid = %sysfunc(open(work.corr_tmp));
16949 +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
16950 +          %do i = 4 %to &nvar;
16951 +          %let _name = %sysfunc(varname(&dsid, &i));
16952 +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
16953 +            %else  %let _name_md = &_name;
16954 +            %if &i < &nvar %then %do;
16955 +               &_name = 1- &_name_md ,
16956 +            %end;
16957 +            %else %do;
16958 +               &_name = &_name_md where _TYPE_ eq 'CORR' ;
16959 +            %end;
16960 +          %end;
16961 +      %let dsid= %sysfunc(close(&dsid));
16962 +
16963 +      select * from &indata;
16964 +      run;
16965 +     data &indata( drop = _NCL_);
16966 +           set &indata;
16967 +           if _TYPE_ not in ('CORR', 'STD', 'N', 'MEAN') then delete;
16968 +           if _TYPE_ ='CORR' then _TYPE_ ='DISTANCE';
16969 +     run;
16970 +     data &indata(DROP = _NCL_);
16971 +           set &indata;
16972 +           if _TYPE_ = 'CORR' then _TYPE_ ='DISTANCE';
16973 +           if _TYPE_ not in ('DISTANCE', 'N', 'STD', 'MEAN') then delete;
16974 +           rename _NAME_ = _VAR_;
16975 +     run;
16976 +     proc datasets lib = work nolist;
16977 +           delete corr_tmp;
16978 +     run;
16979 +     quit;
16980 + %mend UpdateOutStatCorrToDistance;
16981 +
16982 +
16983 +%macro HierClusWithCorr(indata= ,
16984 +                        ncluster=,
16985 +                        method = Ward,
16986 +                        outtree = _outtree,
16987 +                        idvar =_VAR_,
16988 +                        outdata=,
16989 +                        rescore = N,
16990 +                        newncluster=
16991 +                        );
16992 +      %global &newncluster;
16993 +      %if &rescore ne Y %then %do;
16994 +      proc cluster data=&indata(type=Distance where=(upcase(strip(_TYPE_)) = "DISTANCE"))
16995 +                   method=&method outtree=&outtree noprint;
16996 +           id &idvar;
16997 +      run;
16998 +      %end;
16999 +      proc tree data=&outtree nclusters = &ncluster out=&outdata noprint;
17000 +      run;
17001 +      /* ----- Check some variables like CL1, CL5..., remove them ----*/
17002 +      proc contents data =&indata out=_outcontent(keep=NAME) noprint;
17003 +      run;
17004 +      data _outcontent;
17005 +          set _outcontent;
17006 +          if NAME in ('_TYPE_' , '_VAR_') then delete;
17007 +          index = 1;
17008 +          rename NAME = _NAME_;
17009 +      run;
17010 +      proc sort data=_outcontent;
17011 +          by _NAME_;
17012 +      run;
17013 +      proc sort data =&outdata;
17014 +           by _NAME_;
17015 +      run;
17016 +      data &outdata(drop=index);
17017 +          merge &outdata _outcontent;
17018 +          by _NAME_;
17019 +          if index = . then delete;
17020 +      run;
17021 +      /*-----------------------------------------------------------*/
17022 +      data &outdata;
17023 +           length CLUSNAME $16;
17024 +           set &outdata;
17025 +           if CLUSTER > &ncluster then delete;
17026 +           CLUSNAME='GC'||strip(CLUSTER);
17027 +           *label CLUSNAME = "Cluster Name";
17028 +           label CLUSNAME  = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername, noquote))" ;
17029 +           rename _NAME_ = VARIABLE ;
17030 +           *label _NAME_ = "Variable";
17031 +           *label CLUSTER = "Cluster";
17032 +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
17033 +           label CLUSTER ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
17034 +      run;
17035 +      proc sort data=&outdata out=&outdata;
17036 +           by CLUSTER;
17037 +      run;
17038 +      proc means data =&outdata noprint;
17039 +           output out=_meanout;
17040 +      run;
17041 +      data _null_;
17042 +            set _meanout;
17043 +            if strip(_STAT_) eq 'MAX' then do;
17044 +            call symput("&newncluster", CLUSTER);
17045 +            stop;
17046 +            end;
17047 +      run;
17048 +
17049 +      proc datasets lib = work nolist;
17050 +           delete _outcontent _meanout;
17051 +      run;
17052 +      quit;
17053 +%mend  HierClusWithCorr;
17054 +
17055 +%macro CreateScoreCode2(indata=, ncluscomp=, globalclusid=, fileref=);
17056 +
17057 +     data _tmpindata;
17058 +          set &indata;
17059 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
17060 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
17061 +          if _TYPE_ = 'STD' then _NAME_='STD';
17062 +          if _TYPE_ = 'SCORE' then _NAME_=upcase("GC&globalclusid._"||_NAME_);
17063 +          DROP _TYPE_ _NCL_;
17064 +     run;
17065 +
17066 +     filename _file_  "&fileRef";
17067 +
17068 +     data _null_;
17069 +        FILE _file_ MOD;
17070 +        put ' ';
17071 +        put "/*-------------------------------------------------*/";
17072 +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_gclus, noquote, &globalclusid))" '*/';
17073 +        put "/*-------------------------------------------------*/";
17074 +        put ' ';
17075 +        %let dsid = %sysfunc(open(work._tmpindata));
17076 +
17077 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
17078 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
17079 +        %let k = 1;
17080 +        %do %while(^%sysfunc(fetch(&dsid)));
17081 +               %let _name = %sysfunc(getvarc(&dsid, &vn_name));
17082 +               %if &k > 2 %then %do;
17083 +                %let cn = %eval(&k-2);
17084 +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_gcluscompnum, noquote, &globalclusid, &cn))" "------ */";
17085 +                %end;
17086 +                %let k = %eval(&k+1);
17087 +
17088 +        %end;
17089 +        %let rc = %sysfunc(rewind(&dsid));
17090 +
17091 +        %do j= 2 %to &nvar;
17092 +            %let _varname = %sysfunc(varname(&dsid, &j));
17093 +            %do %while(^%sysfunc(fetch(&dsid)));
17094 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
17095 +                %if &_name = MEAN %then
17096 +                %let _mean = %sysfunc(getvarn(&dsid, &j));
17097 +                %else %if &_name = STD %then
17098 +                %let _std = %sysfunc(getvarn(&dsid, &j));
17099 +                %else %do;
17100 +                      %let coeff =  %sysfunc(getvarn(&dsid, &j));
17101 +                      %let abscoeff = %sysfunc(abs(&coeff));
17102 +                          %if &abscoeff >  0 %then %do;
17103 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
17104 +                           %end;
17105 +                 %end;
17106 +             %end;
17107 +             %let rc = %sysfunc(rewind(&dsid));
17108 +         %end;
17109 +
17110 +        %let dsid= %sysfunc(close(&dsid));
17111 +
17112 +     run;
17113 +
17114 +     filename _file_;
17115 +     proc datasets lib = work nolist;
17116 +           delete _tmpindata;
17117 +     run;
17118 +     quit;
17119 +%mend CreateScoreCode2;
17120 +
17121 +
17122 +%macro MakeDeltaCode2(groupds=,deltacodefile=);
17123 +
17124 +     /*--- Build Code to Modify Metadata ---*/
17125 +     filename X "&deltacodefile";
17126 +     data _null_;
17127 +        FILE X;
17128 +        set &groupds end=eof;
17129 +        if _N_=1 then do;
17130 +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
17131 +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
17132 +           %end;
17133 +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
17134 +           put "if upcase(strip(NAME)) in (";
17135 +        end;
17136 +        if Strip(upcase(Selected)) eq 'YES' then do;
17137 +           string = '"'!!trim(left(VARIABLE))!!'"';
17138 +           put string;
17139 +        end;
17140 +        if eof then do;
17141 +           put ') then ROLE="INPUT";';
17142 +           put 'else ROLE="REJECTED";';
17143 +           put 'end;';
17144 +
17145 +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
17146 +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
17147 +           %end;
17148 +        end;
17149 +     run;
17150 +     quit;
17151 +
17152 +     filename X;
17153 +     quit;
17154 +%mend MakeDeltaCode2;
17155 +
17156 +%macro getInitialGClusterNumber(indata=, ninput=, ndummy=0, div=100, ngc=);
17157 +  %global &ngc;
17158 +  data _null_;
17159 +  %if &indata ne %then %do;
17160 +      %let dsid = %sysfunc(open(&indata));
17161 +           %let nvar = %sysfunc(attrn(&dsid, NVAR));
17162 +      %let dsid = %sysfunc(close(&dsid));
17163 +  %end;
17164 +  %else %do;
17165 +       %let nvar = %eval(&ninput+&ndummy); ;
17166 +  %end;
17167 +  %let numgc = %eval(&nvar/&div+2);
17168 +  %let &ngc = &numgc;
17169 +   run;
17170 +  quit;
17171 +%mend getInitialGClusterNumber;
17172 +
17173 +
17174 +%macro MakeGobalConstellData(indata=, outlink=, outnode=);
17175 +data &outlink(drop = Selected);
17176 +     set &indata;
17177 +     LINKID = _N_;
17178 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid, noquote))" ;
17179 +run;
17180 +data &outnode(keep=NODEID TYPE LABEL);
17181 +    set &indata;
17182 +    length TYPE $16;
17183 +    rename VARIABLE = NODEID;
17184 +    *label  CLUSNAME="Node ID";
17185 +    label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
17186 +    TYPE = "VARIABLE";
17187 +    *label TYPE = "Node Type";
17188 +    label TYPE =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
17189 +    run;
17190 +data _tmp(keep=NODEID TYPE LABEL);
17191 +    set &indata;
17192 +    length TYPE $16;
17193 +    rename CLUSNAME = NODEID;
17194 +    label  CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
17195 +    TYPE = "GCLUSTER";
17196 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
17197 +    run;
17198 +proc sort data=_tmp;
17199 +    by NODEID;
17200 +run;
17201 +data _tmp;
17202 +    set _tmp; by NODEID;
17203 +    if first.NODEID then output;
17204 +run;
17205 +proc sort data=&outnode;
17206 +    by NODEID;
17207 +run;
17208 +data  &outnode;
17209 +    set _tmp &outnode;
17210 +run;
17211 +proc datasets lib = work nolist;
17212 +     delete _tmp;
17213 +run;
17214 +quit;
17215 +%mend MakeGobalConstellData;
17216 +
17217 +/* Make contellation plot data among GCLUSTERS */
17218 +
17219 +%Macro MakeGClusterConstData(indata=, inoutrsq=, outnode=, outlink=);
17220 +
17221 +data &outlink(keep = _NAME_ _PARENT_ _LABEL_ LINKID);
17222 +     set &indata;
17223 +     LINKID = _N_;
17224 +     if upcase(substr(strip(_NAME_),1, 2))="CL" then do;
17225 +        _NAME_ = "ROOT"||upcase(substr(strip(_NAME_),5));
17226 +     end;
17227 +     if _PARENT_ ne " " and upcase(substr(strip(_PARENT_),1, 2))="CL" then do;
17228 +        _PARENT_ = "ROOT"||upcase(substr(strip(_PARENT_),5));
17229 +     end;
17230 +     if upcase(substr(strip(_LABEL_),1, 2))="CL" then do;
17231 +        _LABEL_ = "ROOT"||upcase(substr(strip(_LABEL_),5));
17232 +    end;
17233 +run;
17234 +
17235 +data _tmp_outrsquare;
17236 +        set &inoutrsq;
17237 +        if upcase(strip(TYPE)) = 'CLUSTERCOMP' then delete;
17238 +run;
17239 +
17240 +proc freq data =_tmp_outrsquare noprint;
17241 +         tables GCluster/out=_tmp_GCLUSFREQ(rename=(GCLUSTER=_NAME_));
17242 +run;
17243 +
17244 +data &outnode(keep=_NAME_ TYPE LABEL);
17245 +    set &outlink;
17246 +    length TYPE $16;
17247 +    length LABEL $100;
17248 +    /*label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;*/
17249 +
17250 +    if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
17251 +    TYPE = "GCLUSTER";
17252 +    LABEL = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
17253 +    end;
17254 +    else do;
17255 +    TYPE= "ROOT";
17256 +    LABEL= _NAME_;
17257 +    end;
17258 +    label TYPE  =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
17259 +    label LABEL =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
17260 +    label _NAME_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
17261 +    run;
17262 +
17263 +proc sort data=&outnode;
17264 +     by _NAME_;
17265 +proc sort data=_tmp_GCLUSFREQ;
17266 +     by _NAME_;
17267 +run;
17268 +
17269 +data  &outnode;
17270 +     merge &outnode _tmp_GCLUSFREQ; by _NAME_;
17271 +     if COUNT=. then COUNT=1;
17272 +run;
17273 +
17274 +proc datasets lib = work nolist;
17275 +     delete _tmp_outrsquare _tmp_GCLUSFREQ;
17276 +run;
17277 +
17278 +quit;
17279 +%Mend MakeGClusterConstData;
17280 +
17281 +
17282 +%macro CreateGClusterScoreCode(indata=,  globalclusid=, fileref=);
17283 +
17284 +    data _gscoretmpds;
17285 +          set &indata;
17286 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = 1 ) or (_TYPE_ in ('MEAN' 'STD'));
17287 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
17288 +          if _TYPE_ = 'STD' then _NAME_='STD';
17289 +          if _TYPE_ = 'SCORE' then _NAME_ = "GC"||strip(&globalclusid);
17290 +          DROP _TYPE_ _NCL_;
17291 +     run;
17292 +
17293 +    /*  %let gscorefile =  %bquote(&EM_NODEDIR)&EM_DSEP.gclusterscore.sas;
17294 +        GCluster Component &globalclusid ------ */
17295 +
17296 +    filename _file_  "&fileref";
17297 +
17298 +    data _null_;
17299 +        %if &globalclusid eq 1 %then %do;
17300 +          FILE _file_;
17301 +        %end;
17302 +        %else %do;
17303 +          FILE _file_ MOD;
17304 +        %end;
17305 +
17306 +        %let dsid = %sysfunc(open(work._gscoretmpds));
17307 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
17308 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
17309 +
17310 +        %let k = 1;
17311 +        %do %while(^%sysfunc(fetch(&dsid)));
17312 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
17313 +                %if &k > 2 %then %do;
17314 +                put "&_name = 0 ; ";
17315 +                %end;
17316 +                %let k = %eval(&k+1);
17317 +        %end;
17318 +
17319 +        %let rc = %sysfunc(rewind(&dsid));
17320 +        %do i= 2 %to &nvar;
17321 +            %let _varname =  %sysfunc(varname(&dsid, &i));
17322 +            %do %while(^%sysfunc(fetch(&dsid)));
17323 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
17324 +                %if &_name = MEAN %then
17325 +                %let _mean = %sysfunc(getvarn(&dsid, &i));
17326 +                %else %if &_name = STD %then
17327 +                %let _std = %sysfunc(getvarn(&dsid, &i));
17328 +                %else %do;
17329 +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
17330 +                      %let abscoeff = %sysfunc(abs(&coeff));
17331 +                          %if &abscoeff >  0 %then %do;
17332 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
17333 +                           %end;
17334 +                 %end;
17335 +             %end;
17336 +             %let rc = %sysfunc(rewind(&dsid));
17337 +
17338 +         %end;
17339 +
17340 +        %let dsid= %sysfunc(close(&dsid));
17341 +       run;
17342 +
17343 +
17344 +       proc datasets lib=work nolist;
17345 +            delete _gscoretmpds;
17346 +       run;
17347 +      quit;
17348 +
17349 +%mend CreateGClusterScoreCode;
17350 +
17351 +
17352 +%macro MakeGClusterCorrelation(Indata=, ngcluster=, gscorecode=, outrsquare=);
17353 +
17354 +   %EM_REGISTER(KEY=GSCORE, TYPE=DATA);
17355 +   %EM_GETNAME(KEY=GSCORE, TYPE=DATA);
17356 +   %EM_REGISTER(KEY=GSCORESTAT, TYPE=DATA);
17357 +   %EM_GETNAME(KEY=GSCORESTAT, TYPE=DATA);
17358 +   %EM_REGISTER(KEY=GSCORETREE, TYPE=DATA);
17359 +   %EM_GETNAME(KEY=GSCORETREE, TYPE=DATA);
17360 +   %EM_REGISTER(KEY=GSCORECORR, TYPE=DATA);
17361 +   %EM_GETNAME(KEY=GSCORECORR, TYPE=DATA);
17362 +   %EM_REGISTER(KEY=GSCORECORRPLOT, TYPE=DATA);
17363 +   %EM_GETNAME(KEY=GSCORECORRPLOT, TYPE=DATA);
17364 +   %EM_REGISTER(KEY=GCLUSLINK, TYPE=DATA);
17365 +   %EM_GETNAME(KEY=GCLUSLINK, TYPE=DATA);
17366 +   %EM_REGISTER(KEY=GCLUSNODE, TYPE=DATA);
17367 +   %EM_GETNAME(KEY=GCLUSNODE, TYPE=DATA);
17368 +
17369 +   filename gsfile "&gscorecode";
17370 +
17371 +   data &EM_USER_GSCORE;
17372 +             set &indata;
17373 +             %include  gsfile;
17374 +        keep
17375 +        %do i=1 %to &ngcluster;
17376 +         %let gcvarname = GC&i;
17377 +         &gcvarname
17378 +        %end;
17379 +     ;
17380 +   run;
17381 +
17382 +   proc varclus data=&EM_USER_GSCORE outstat=&EM_USER_GSCORESTAT outtree=&EM_USER_GSCORETREE
17383 +    %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
17384 +    %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
17385 +    %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
17386 +    noprint  ;
17387 +     var
17388 +       %do i=1 %to &ngcluster;
17389 +         %let gcvarname = GC&i;
17390 +         &gcvarname
17391 +        %end;
17392 +   ;
17393 +   run;
17394 +
17395 +
17396 +   %MakeVarClusCorrData(statds=&EM_USER_GSCORESTAT, corrds=&EM_USER_GSCORECORR, corrplotds=&EM_USER_GSCORECORRPLOT );
17397 +   data &EM_USER_GSCORECORRPLOT ;
17398 +        set &EM_USER_GSCORECORRPLOT;
17399 +        rename _X_ = X;
17400 +        rename _Y_ = Y;
17401 +        label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
17402 +        label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
17403 +   run;
17404 +
17405 +   %MakeGClusterConstData(indata=&EM_USER_GSCORETREE, inoutrsq=&outrsquare, outnode=&EM_USER_GCLUSNODE, outlink=&EM_USER_GCLUSLINK);
17406 +
17407 +   data &EM_USER_GSCORETREE;
17408 +        length _NAME_ $32;
17409 +        length _LABEL_ $100;
17410 +        set &EM_USER_GSCORETREE(DROP=_LABEL_);
17411 +        if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
17412 +         _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
17413 +        end;else do;
17414 +         _LABEL_ = _NAME_;
17415 +        end;
17416 +       label _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
17417 +
17418 +   run;
17419 +
17420 +   quit;
17421 +
17422 +%mend MakeGClusterCorrelation;
17423 +
17424 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_TRAIN.SOURCE.
17427 +%macro train;
17429 +   filename temp catalog 'sashelp.emexpl.variableclustering_train1.source';
17430 +   %include temp;
17431 +   filename temp catalog 'sashelp.emexpl.variableclustering_train2.source';
17432 +   %include temp;
17433 +   filename temp catalog 'sashelp.emutil.em_copyfile.source';
17434 +   %include temp;
17435 +   filename temp;
17437 +   %let VARCLUS_MAXNUMOBS = 100000;
17438 +   %let VARCLUS_MAXNUMVAR = 200;
17439 +   %let trainnum = 0;
17440 +   %let error = 0;
17442 +   %if &EM_IMPORT_DATA eq %then %do;
17443 +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
17444 +       %let  error = 1;
17445 +       %goto endtrain;
17446 +   %end;
17448 +    %if (%sysfunc(exist(&EM_IMPORT_DATA)) or %sysfunc(exist(&EM_IMPORT_DATA, VIEW))) < 1 %then %do;
17449 +        %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
17450 +        %let  error = 1;
17451 +        %goto endline;
17452 +    %end;
17454 +   %let _num_input_interval = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
17455 +   %let _num_input_binary = %eval(&EM_NUM_BINARY_INPUT+&EM_NUM_BINARY_REJECTED);
17456 +   %let _num_input_nominal = %eval(&EM_NUM_NOMINAL_INPUT+&EM_NUM_NOMINAL_REJECTED);
17457 +   %let _num_input_ordinal = %eval(&EM_NUM_ORDINAL_INPUT+&EM_NUM_ORDINAL_REJECTED);
17458 +   %let _num_input_class = %eval(&_num_input_binary+&_num_input_nominal+&_num_input_ordinal);
17459 +   %let _num_input_total = %eval(&_num_input_interval+&_num_input_class);
17461 +   %if (&EM_PROPERTY_INCLUDECLASSVAR eq Y) %then %do;
17462 +        %if  &_num_input_total < 2 %then %do;
17463 +            %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
17464 +            %let error = 2;
17465 +            %goto endtrain;
17466 +        %end;
17467 +   %end;
17468 +   %else %do;
17469 +         %if  &_num_input_interval < 2 %then %do;
17470 +         %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
17471 +         %let error = 2;
17472 +         %goto endtrain;
17473 +         %end;
17474 +   %end;
17476 +   %em_checkerror();
17478 +   %if &EMEXCEPTIONSTRING ne %then %do;
17479 +       %goto endtrain;
17480 +   %end;
17482 +   %if (&EM_PROPERTY_INCLUDECLASSVAR eq Y) and (&_num_input_class > 0) %then %do;
17484 +        %EM_GETNAME(key=OUTDUMMY, type=DATA);
17485 +        %MakeDummyVariables( indata=&EM_IMPORT_DATA,
17486 +                             outvar=&EM_USER_OUTDUMMY,
17487 +                             outdata=_newtrainds,
17488 +                             fileref=&EM_FILE_EMFLOWSCORECODE);
17490 +       %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
17491 +           %getNObs(inds=_newtrainds, nobs=_varclus_nobs);
17492 +            %if &_varclus_nobs > &VARCLUS_MAXNUMOBS  %then %do;
17493 +                proc datasets lib=work nolist;
17494 +                delete  _newtrainds;
17495 +                run;
17496 +                quit;
17497 +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning;
17498 +                %let error = 3;
17499 +               %goto endtrain;
17500 +            %end;
17501 +        %end;
17503 +        %if &EM_PROPERTY_TWOSTAGECLUS eq AUTO %then %do;
17504 +             %getNVar(inds=_newtrainds, nvar=_nvar);
17506 +            %if &_nvar > &VARCLUS_MAXNUMVAR %then %do;
17507 +                %let trainnum = 2;
17508 +            %end;
17509 +            %else %do;
17510 +                %let trainnum = 1;
17511 +            %end;
17512 +        %end;
17513 +    %end;
17514 +    %else %do;
17516 +          %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
17518 +            %getNObs(inds=&EM_IMPORT_DATA, nobs=_varclus_nobs);
17520 +            %if &_varclus_nobs > &VARCLUS_MAXNUMOBS  %then %do;
17522 +                 %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning;
17523 +                  %let error = 3;
17524 +                 %goto endtrain;
17525 +            %end;
17526 +        %end;
17529 +         %if &EM_PROPERTY_TWOSTAGECLUS eq AUTO %then %do;
17530 +            /*%getNVar(inds=&EM_IMPORT_DATA, nvar=_nvar);
17531 +              %if &_nvar > &VARCLUS_MAXNUMVAR %then %do;*/
17532 +            %if &EM_NUM_INTERVAL_INPUT > &VARCLUS_MAXNUMVAR %then %do;
17533 +                %let trainnum = 2;
17534 +            %end;
17535 +            %else %do;
17536 +                %let trainnum = 1;
17537 +            %end;
17538 +        %end;
17540 +   %end;
17542 +    %em_checkerror();
17544 +    %if &EMEXCEPTIONSTRING ne %then %do;
17545 +       %let error = 4;
17546 +       %goto endtrain;
17547 +    %end;
17549 +    %CreateVarclusMeta(trainnum=&trainnum);
17551 +    %if &error > 0 %then  %goto endtrain;
17553 +       /* when only EM_PROPERTY_TWOSTAGECLUS eq AUTO &_triannum will be 1 or 2  */
17555 +       %if (&trainnum = 1 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = NO %then %do;
17556 +           %train1;
17557 +       %end;
17558 +       %if (&trainnum = 2 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = YES %then %do;
17559 +           %train2;
17560 +       %end;
17562 +      filename _in  "&EM_FILE_EMFLOWSCORECODE";
17563 +      filename _out "&EM_FILE_EMPUBLISHSCORECODE";
17564 +      data _null_;
17565 +         length line $20000;
17566 +         file _out lrecl=20000;
17567 +         fid=fopen("_in",'i',20000,'v');
17568 +         if fid > 0  then do;
17569 +            do while(^fread(fid));
17570 +               rlen = frlen(fid);
17571 +               rc= fget(fid,line,20000);
17572 +               start = length(line)-length(left(line))+1;
17573 +               line=strip(line);
17574 +               if line ne 'delete;' then do;
17575 +                  put @start line;
17576 +               end;
17577 +            end;
17578 +            if fid > 0  then rc=fclose(fid);
17579 +         end;
17580 +      run;
17581 +      filename _in;
17582 +      filename _out;
17584 +   %endtrain:
17587 +%mend train;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_TRAIN1.SOURCE.
17589 +%macro VarClus(indata=,
17590 +               outstat=,
17591 +               outtree=,
17592 +               vars=,
17593 +               freq=,
17594 +               weight=,
17595 +               includeclassvar=
17596 +               );
17598 +   %if &vars eq %then
17599 +       %let vars = %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED;
17601 +        /*Add by ruzhan, May 28, 2013*/
17602 +        ods graphics on;
17603 +        %let odspath =;
17604 +        data _null_;
17605 +            path = pathname('WORK');
17606 +            call symput('odspath', path);
17607 +        run;
17608 +        ods listing gpath="&odspath";
17609 +        ods output DENDROGRAM=&outtree;
17610 +       proc varclus data = &indata outstat= &outstat
17611 +        %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
17612 +        %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
17613 +        %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
17614 +        /*-----------------------
17615 +        %if %upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT %then %do;
17616 +            %let maxc = %sysevalf(&EM_PROPERTY_MAXCLUS, int);
17617 +            %if &maxc > 1 %then %do;     maxc=&maxc %end;
17618 +       %end;
17619 +       -------------------------*/
17620 +       %if (&EM_PROPERTY_MAXCLUS ne . )  and (%upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT) %then %do;
17621 +            maxc = &EM_PROPERTY_MAXCLUS
17622 +       %end;
17624 +       /*------------------------------------------------------------------------------------------------------
17625 +        (%upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT) is needed because of diagram conversion from Em12.1 to 12.3
17626 +        ------------------------------------------------------------------------------------------------------*/
17628 +       %if (%upcase(&EM_PROPERTY_CLUSCOMP) ne CENTROID) and
17629 +           ( ( &EM_PROPERTY_MAXEIGEN ne . )  and (%upcase(&EM_PROPERTY_MAXEIGEN) ne DEFAULT) ) %then %do;
17630 +            maxeigen = &EM_PROPERTY_MAXEIGEN
17631 +       %end;
17633 +       %if &EM_PROPERTY_PROPORTION ne 0  and (%upcase(&EM_PROPERTY_PROPORTION) ne DEFAULT) %then %do;
17634 +            proportion = &EM_PROPERTY_PROPORTION
17635 +       %end;
17636 +       %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SUMMARY %then %do;
17637 +               summary
17638 +       %end;
17640 +       %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SHORT %then %do;
17641 +           short
17642 +       %end;
17643 +        %if %upcase(&EM_PROPERTY_PRINTOPTION) eq ALL %then %do;
17644 +           corr trace simple
17645 +       %end;
17646 +       %if %upcase(&EM_PROPERTY_PRINTOPTION) eq NONE %then %do;
17647 +          noprint
17648 +       %end;
17649 +        /*Comment out by ruzhan, May 28, 2013*/
17650 +       /*       outtree=&outtree*/
17651 +       ;
17652 +        var %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED
17654 +      %if &includeclassvar eq Y %then %do;
17655 +          %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
17656 +          %if &dsid > 0 %then %do;
17657 +             %let nvar = %sysfunc(attrn(&dsid, NVAR));
17658 +              %do i = 2 %to &nvar;
17659 +                  %let varname = %sysfunc(varname(&dsid, &i));
17660 +                   &varname
17661 +              %end;
17663 +          %end;
17664 +      %end;
17666 +      ;
17667 +      /*------------------------
17668 +      %if &freq ne  %then %do;
17669 +          freq &freq;
17670 +      %end;
17671 +      %if &weight ne  %then %do;
17672 +          weight &weight;
17673 +      %end;
17674 +      ----------------------------*/
17675 +      %if %EM_FREQ ne %then %do;
17676 +           Freq %EM_FREQ;
17677 +      %end;
17678 +      ;
17679 +    run;
17680 +    ods graphics off;
17681 +    %endline:
17682 +    quit;
17683 +%mend VarClus;
17685 +%macro Train1;
17687 +   %EM_GETNAME(key=OUTCORRPLOT, type=DATA) ;
17688 +   %EM_GETNAME(key=OUTCORR, type=DATA) ;
17689 +   %EM_GETNAME(key=OUTSTAT, type=DATA) ;
17690 +   %EM_GETNAME(key=OUTGROUP, type=DATA) ;
17691 +   %EM_GETNAME(key=OUTSTATPLOT, type=DATA) ;
17692 +   %EM_GETNAME(key=OUTTREE, type=DATA) ;
17693 +   %EM_GETNAME(key=OUTRSQUARE, type=DATA) ;
17694 +   %EM_GETNAME(key=OUTCLUSSTRUCT, type=DATA) ;
17695 +   %EM_GETNAME(key=OUTCLUSCORR, type=DATA) ;
17696 +   %EM_GETNAME(key=OUTCLUSCORRPLOT, type=DATA) ;
17697 +   %EM_GETNAME(key=OUTCLUSRSQUARE, type=DATA) ;
17698 +   %EM_GETNAME(key=OUTLINK, type=DATA) ;
17699 +   %EM_GETNAME(key=OUTNODE, type=DATA) ;
17701 +   /*
17702 +     %let VARCLUS_MAXNUMOBS = 100;
17703 +     %let VARCLUS_MAXNUMVAR = 200;
17704 +   */
17706 +   /* Train
17708 +   %if &EM_IMPORT_DATA eq %then %do;
17709 +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
17710 +       %goto endtrain1;
17711 +   %end;
17713 +   %if  &EM_NUM_INTERVAL_INPUT < 2 %then %do;
17714 +        %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
17715 +        %goto endtrain1;
17716 +   %end;
17717 +   */
17718 +   %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
17719 +       /* moved this to pretrain ------------
17721 +        %EM_GETNAME(key=OUTDUMMY, type=DATA);
17722 +        %MakeDummyVariables( indata=&EM_IMPORT_DATA,
17723 +                             outvar=&EM_USER_OUTDUMMY,
17724 +                             outdata=_newtrainds,
17725 +                             fileref=&EM_FILE_EMFLOWSCORECODE);
17727 +        %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
17728 +            %getNVarNObs(inds=_newtrainds, nvar=_nvar, nobs=_nobs);
17729 +            %if &_nobs > &VARCLUS_MAXNUMOBS ne %then %do;
17730 +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning
17731 +                %goto endtrain;
17732 +            %end;
17733 +        %end;
17735 +        +-------------------------------------*/
17737 +        %if (%sysfunc(exist(_newtrainds)) or %sysfunc(exist(_newtrainds, VIEW))) < 1 %then %do;
17738 +        /*when there is no class var and &EM_PROPERTY_INCLUDECLASSVAR eq Y
17739 +          There is no _newtrainds */
17740 +         %VarClus( indata=&EM_IMPORT_DATA,
17741 +                  outstat=&EM_USER_OUTSTAT,
17742 +                  outtree = &EM_USER_OUTTREE,
17743 +                  includeclassvar=N
17744 +                 );
17745 +        %end;
17746 +        %else %do;
17747 +        %VarClus( indata=_newtrainds,
17748 +                  outstat=&EM_USER_OUTSTAT,
17749 +                  outtree = &EM_USER_OUTTREE,
17750 +                  includeclassvar=Y
17751 +                 );
17752 +         proc datasets lib=work nolist;
17753 +              delete  _newtrainds;
17754 +         run;
17755 +         %end;
17756 +    %end;
17757 +    %else %do;
17759 +        /*----- moved this to pretrain ------------
17760 +        %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
17761 +            %getNVarNObs(inds=&EM_IMPORT_DATA, nvar=_nvar, nobs=_nobs);
17762 +            %if &_nobs > &VARCLUS_MAXNUMOBS ne %then %do;
17763 +                 %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning;
17764 +                 %goto endtrain;
17765 +            %end;
17766 +        %end;
17767 +        +-------------------------------------*/
17769 +        %VarClus(indata=&EM_IMPORT_DATA,
17770 +                  outstat=&EM_USER_OUTSTAT,
17771 +                  outtree =&EM_USER_OUTTREE,
17772 +                  includeclassvar=N
17773 +               );
17775 +   %end;
17777 +   %em_checkerror();
17779 +   %if &EMEXCEPTIONSTRING ne %then %do;
17780 +       %goto endtrain1;
17781 +   %end;
17782 +    /*
17783 +    %FindClusNum(statds=&EM_USER_OUTSTAT, groupds=&EM_USER_OUTGROUP, minvariation=&EM_PROPERTY_MINVARIATION);
17784 +    */
17786 +    %getNclusfromTrain(inoutstat=&EM_USER_OUTSTAT, nc=_nclus);
17788 +    %let gid=;
17790 +    /*--- To make the main result table ----------------------*/
17792 +    %MakeInterClusCorrData(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=&EM_USER_OUTCLUSCORR, ncluster=&_nclus, RSquare=Y);
17793 +    %FindNextClosestClusByCluster(indata=&EM_USER_OUTCLUSCORR, outdata=_nextClusRSq, globalclusid=&gid, ncluster=&_nclus);
17794 +    %MakeOwnRSquare(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=_ownRsq, ncluster=&_nclus);
17795 +    %MakeClusStructCorrData(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=&EM_USER_OUTCLUSSTRUCT , ncluster=&_nclus, Rsquare=Y);
17796 +    %FindNextClosestClusByVar(indata=&EM_USER_OUTCLUSSTRUCT, outdata=_nextVarRSq, globalclusid=&gid, ncluster=&_nclus);
17797 +    %MakeVarClusResultTable(indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq, outdata=&EM_USER_OUTRSQUARE, globalclusid=&gid, ncluster=&_nclus, selectedcomp=&EM_PROPERTY_EXPORTEDCOMP);
17799 +   /* Inter Cluster Correlation Plot ------------------------*/
17801 +    %MakeInterClusCorrData(indata=&EM_USER_OUTSTAT, globalclusid=&gid, outdata=&EM_USER_OUTCLUSCORRPLOT, ncluster=&_nclus, RSquare=N);
17802 +    %MakePlotDataFromCorrTable(indata=&EM_USER_OUTCLUSCORRPLOT, outdata=&EM_USER_OUTCLUSCORRPLOT, globalclusid=&gid);
17804 +   /* Create some other data sets for results ----*/
17806 +   %MakeStatPlotData(statds=&EM_USER_OUTSTAT , outstatplotds=&EM_USER_OUTSTATPLOT);
17807 +   %MakeVarClusCorrData(statds=&EM_USER_OUTSTAT, corrds=&EM_USER_OUTCORR, corrplotds=&EM_USER_OUTCORRPLOT);
17808 +   %MakeClusConstellData(indata=&EM_USER_OUTRSQUARE, outlink=&EM_USER_OUTLINK, outnode=&EM_USER_OUTNODE);
17810 +  /*---- move this to Score action ------------
17811 +   %MakeDeltaCode(groupds=&EM_USER_OUTRSQUARE, DeltaCodeFile=&EM_FILE_CDELTA_TRAIN);
17812 +   */
17814 +   /* create score code at training time */
17815 +   %CreateScoreCode(indata=&EM_USER_OUTSTAT, ncluscomp=&_nclus, fileref=&EM_FILE_EMFLOWSCORECODE);
17816 +   %endtrain1:
17817 +%mend Train1;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_TRAIN2.SOURCE.
17820 +%macro VarClus2( indata=,
17821 +                 outdata=,
17822 +                 outstat =outstat,
17823 +                 outrsquare=outrsquare,
17824 +                 outtree = outtree,
17825 +                 outclusstruct = outclusstruct,
17826 +                 outcluscorr =outcluscorr,
17827 +                 outcluscorrplot =outcluscorrplot,
17828 +                 outclusrsquare =outclusrsquare,
17829 +                 outstatplot = outstatplot,
17830 +                 outcorr = outcorr,
17831 +                 outcorrplot = outcorrplot,
17832 +                 clusdata=,
17833 +                 outnode=outnode,
17834 +                 outlink=outlink,
17835 +                 ngroup =1  );
17836 +         %if (%sysfunc(exist(&indata)) or %sysfunc(exist(&indata, VIEW))) < 1 %then %do;
17837 +              %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
17838 +              %goto endline;
17839 +         %end;
17841 +        %global numglobalcluster;
17842 +        %let  numglobalcluster = &ngroup;
17843 +        %let  gscorefile =  %bquote(&EM_NODEDIR)&EM_DSEP.gclusterscore.sas;
17844 +        %do vci =1 %to &ngroup;
17845 +           data tmp_clusdata;
17846 +                set &clusdata;
17847 +                if CLUSTER ne &vci then delete;
17848 +           run;
17849 +           %let outstatds = &outstat.&vci;
17850 +           %let outrsquareds = &outrsquare.&vci;
17851 +           %let outtreeds = &outtree.&vci;
17852 +           %let outclusstuctds = &outclusstruct.&vci;
17853 +           %let outcluscorrds = &outcluscorr.&vci;
17854 +           %let outcluscorrplotds = &outcluscorrplot.&vci;
17855 +           %let outclusrsquareds = &outclussquare.&vci;
17856 +           %let outstatplotds = &outstatplot.&vci;
17857 +           %let outcorrds = &outcorr.&vci;
17858 +           %let outcorrplotds = &outcorrplot.&vci;
17859 +           %let outnodeds = &outnode.&vci;
17860 +           %let outlinkds = &outlink.&vci;
17862 +           %EM_REGISTER(KEY=&outstatds, TYPE=DATA);
17863 +           %EM_GETNAME(KEY=&outstatds, TYPE=DATA);
17864 +           %let emuseroutstat = &EM_USER_&outstatds;
17866 +           %EM_REGISTER(KEY=&outtreeds, TYPE=DATA);
17867 +           %EM_GETNAME(KEY=&outtreeds, TYPE=DATA);
17868 +           %let emuserouttree = &EM_USER_&outtreeds;
17870 +           %EM_REGISTER(KEY=&outcluscorrds, TYPE=DATA);
17871 +           %EM_GETNAME(KEY=&outcluscorrds, TYPE=DATA);
17872 +           %let emuseroutcluscorr = &EM_USER_&outcluscorrds;
17874 +           %EM_REGISTER(KEY=&outclusstuctds, TYPE=DATA);
17875 +           %EM_GETNAME(KEY=&outclusstuctds, TYPE=DATA);
17876 +           %let emuseroutclusstruct = &EM_USER_&outclusstuctds;
17878 +           %EM_REGISTER(KEY=&outrsquareds, TYPE=DATA);
17879 +           %EM_GETNAME(KEY=&outrsquareds, TYPE=DATA);
17880 +           %let emuseroutrsquare = &EM_USER_&outrsquareds;
17882 +           %EM_REGISTER(KEY=&outcluscorrplotds, TYPE=DATA);
17883 +           %EM_GETNAME(KEY=&outcluscorrplotds, TYPE=DATA);
17884 +           %let emuseroutcluscorrplot = &EM_USER_&outcluscorrplotds;
17886 +           %EM_REGISTER(KEY=&outstatplotds, TYPE=DATA);
17887 +           %EM_GETNAME(KEY=&outstatplotds, TYPE=DATA);
17888 +           %let emuseroutstatplot = &EM_USER_&outstatplotds;
17890 +           %EM_REGISTER(KEY=&outcorrds, TYPE=DATA);
17891 +           %EM_GETNAME(KEY=&outcorrds, TYPE=DATA);
17892 +           %let emuseroutcorr = &EM_USER_&outcorrds;
17894 +           %EM_REGISTER(KEY=&outcorrplotds, TYPE=DATA);
17895 +           %EM_GETNAME(KEY=&outcorrplotds, TYPE=DATA);
17896 +           %let emuseroutcorrplot = &EM_USER_&outcorrplotds;
17898 +           %EM_REGISTER(KEY=&outnodeds, TYPE=DATA);
17899 +           %EM_GETNAME(KEY=&outnodeds, TYPE=DATA);
17900 +           %let emuseroutnode = &EM_USER_&outnodeds;
17902 +           %EM_REGISTER(KEY=&outlinkds, TYPE=DATA);
17903 +           %EM_GETNAME(KEY=&outlinkds, TYPE=DATA);
17904 +           %let emuseroutlink = &EM_USER_&outlinkds;
17906 +           /*Add by ruzhan, May 28, 2013*/
17907 +           ods graphics on;
17908 +            %let odspath =;
17909 +            data _null_;
17910 +                path = pathname('WORK');
17911 +                call symput('odspath', path);
17912 +            run;
17913 +            ods listing gpath="&odspath";
17915 +           ods output DENDROGRAM=&emuserouttree;
17917 +           proc varclus data=&indata outstat=&emuseroutstat
17918 +            %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
17919 +            %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
17920 +            %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
17921 +            %if (&EM_PROPERTY_MAXCLUS ne .)  and (%upcase(&EM_PROPERTY_MAXCLUS) ne DEFAULT) %then %do;
17922 +                  maxc=&EM_PROPERTY_MAXCLUS
17923 +           %end;
17925 +            %if (%upcase(&EM_PROPERTY_CLUSCOMP) ne CENTROID) and
17926 +                ( (&EM_PROPERTY_MAXEIGEN ne .)  and (%upcase(&EM_PROPERTY_MAXEIGEN) ne DEFAULT)) %then %do;
17927 +            maxeigen = &EM_PROPERTY_MAXEIGEN
17928 +            %end;
17930 +           %if (&EM_PROPERTY_PROPORTION ne 0)  and (%upcase(&EM_PROPERTY_PROPORTION) ne DEFAULT) %then %do;
17931 +                proportion = &EM_PROPERTY_PROPORTION
17932 +           %end;
17933 +           %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SUMMARY %then %do;
17934 +               summary
17935 +           %end;
17936 +           %if %upcase(&EM_PROPERTY_PRINTOPTION) eq SHORT %then %do;
17937 +               short
17938 +           %end;
17939 +            %if %upcase(&EM_PROPERTY_PRINTOPTION) eq ALL %then %do;
17940 +               corr trace simple
17941 +           %end;
17942 +           %if %upcase(&EM_PROPERTY_PRINTOPTION) eq NONE %then %do;
17943 +               noprint
17944 +           %end;
17945 +            /*Comment out by ruzhan, May 28, 2013*/
17946 +              /*outtree=&emuserouttree*/
17947 +           ;
17948 +           var
17949 +           %let dsid=%sysfunc(open(work.tmp_clusdata));
17950 +           %let vn_name =%sysfunc(varnum(&dsid, VARIABLE));
17951 +                %do %while(^%sysfunc(fetch(&dsid)));
17952 +                    %let _varname= %sysfunc(getvarc(&dsid, &vn_name));
17953 +                    &_varname
17954 +                %end;
17955 +            %let dsid = %sysfunc(close(&dsid));
17956 +           ;
17957 +           %if %EM_FREQ ne %then %do;
17958 +           Freq %EM_FREQ;
17959 +           %end;
17960 +           run;
17961 +            ods graphics off;
17962 +            %getNclusfromTrain(inoutstat=&emuseroutstat, nc=_nclus);
17964 +            %let gid=&vci;
17965 +            /*--- To make the main result table ----------------------*/
17966 +            %MakeInterClusCorrData(indata=&emuseroutstat, globalclusid=&gid, outdata=&emuseroutcluscorr, ncluster=&_nclus, RSquare=Y);
17967 +            %FindNextClosestClusByCluster(indata=&emuseroutcluscorr, outdata=_nextClusRSq, globalclusid=&gid, ncluster=&_nclus);
17968 +            %MakeOwnRSquare(indata=&emuseroutstat, globalclusid=&gid, outdata=_ownRsq, ncluster=&_nclus);
17969 +            %MakeClusStructCorrData(indata=&emuseroutstat, globalclusid=&gid, outdata=&emuseroutclusstruct , ncluster=&_nclus, Rsquare=Y);
17970 +            %FindNextClosestClusByVar(indata=&emuseroutclusstruct, outdata=_nextVarRSq, globalclusid=&gid, ncluster=&_nclus);
17971 +            %MakeVarClusResultTable(indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq, outdata=&emuseroutrsquare, globalclusid=&gid, ncluster=&_nclus, selectedcomp=&EM_PROPERTY_EXPORTEDCOMP);
17973 +            /* Inter Cluster Correlation Plot ------------------------*/
17975 +            %MakeInterClusCorrData(indata=&emuseroutstat, globalclusid=&gid, outdata=&emuseroutcluscorrplot, ncluster=&_nclus, RSquare=N);
17976 +            %MakePlotDataFromCorrTable(indata=&emuseroutcluscorrplot, outdata=&emuseroutcluscorrplot, globalclusid=&gid);
17978 +           /* Create some other data sets for results ---------------*/
17980 +           %MakeStatPlotData(statds=&emuseroutstat , outstatplotds=&emuseroutstatplot);
17981 +           %MakeVarClusCorrData(statds=&emuseroutstat, corrds=&emuseroutcorr, corrplotds=&emuseroutcorrplot);
17982 +           %MakeClusConstellData(indata=&emuseroutrsquare, outlink=&emuseroutlink, outnode=&emuseroutnode);
17984 +           %CreateScoreCode2(indata=&emuseroutstat, ncluscomp=&_nclus, globalclusid=&gid, fileref=&EM_FILE_EMFLOWSCORECODE);
17986 +           %CreateGClusterScoreCode(indata=&emuseroutstat,  globalclusid=&gid, fileref=&gscorefile);
17988 +           %if &vci = 1 %then %do;
17989 +           data &EM_USER_OUTRSQUARE;
17990 +                set &emuseroutrsquare;
17991 +           run;
17992 +           %end;
17993 +           %else %do;
17994 +           data &EM_USER_OUTRSQUARE;
17995 +                set &EM_USER_OUTRSQUARE &emuseroutrsquare;
17996 +           run;
17997 +           %end;
17998 +           quit;
17999 +       %end;
18001 +       /*---- move this to Score action ------------
18002 +       %MakeDeltaCode2(groupds=&EM_USER_OUTRSQUARE, DeltaCodeFile=&EM_FILE_CDELTA_TRAIN);
18003 +       */
18005 +       /* Make Score Gcluster component & correlation  */
18006 +       %MakeGClusterCorrelation(Indata=&indata, ngcluster=&ngroup, gscorecode=&gscorefile, outrsquare=&EM_USER_OUTRSQUARE);
18008 +       quit;
18009 +       %endline:
18010 +%mend VarClus2;
18013 +%macro Train2;
18015 +   %EM_GETNAME(key=OUTCORRPLOT, type=DATA) ;
18016 +   %EM_GETNAME(key=OUTCORR, type=DATA) ;
18017 +   %EM_GETNAME(key=OUTSTAT, type=DATA) ;
18018 +   %EM_GETNAME(key=OUTGROUP, type=DATA) ;
18019 +   %EM_GETNAME(key=OUTSTATPLOT, type=DATA) ;
18020 +   %EM_GETNAME(key=OUTTREE, type=DATA) ;
18021 +   %EM_GETNAME(key=OUTRSQUARE, type=DATA) ;
18022 +   %EM_GETNAME(key=OUTCLUSSTRUCT, type=DATA) ;
18023 +   %EM_GETNAME(key=OUTCLUSCORR, type=DATA) ;
18024 +   %EM_GETNAME(key=OUTCLUSCORRPLOT, type=DATA) ;
18025 +   %EM_GETNAME(key=OUTCLUSRSQUARE, type=DATA) ;
18026 +   %EM_GETNAME(key=GOUTSTAT, type=DATA) ;
18027 +   %EM_GETNAME(key=GOUTTREE, type=DATA) ;
18028 +   %EM_GETNAME(key=GOUTCORR, type=DATA) ;
18029 +   %EM_GETNAME(key=GOUTGROUP, type=DATA) ;
18030 +   %EM_GETNAME(key=GOUTNODE, type=DATA) ;
18031 +   %EM_GETNAME(key=GOUTLINK, type=DATA) ;
18032 +   %EM_GETNAME(key=VARCLUSMETA, type=DATA) ;
18036 +    /* Train */
18038 +   /* moved to pretrain ------------
18040 +   %if &EM_IMPORT_DATA eq %then %do;
18041 +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN,1;
18042 +       %goto endtrain2;
18043 +   %end;
18045 +   %if  &EM_NUM_INTERVAL_INPUT < 2 %then %do;
18046 +        %let  EMEXCEPTIONSTRING = exception.server.METADATA.USEATLEAST2INPUTREJECT;
18047 +        %goto endtrain2;
18048 +   %end;
18049 +   +-------------------------------------------*/
18051 +    %let _num_input_interval = %eval(&EM_NUM_INTERVAL_INPUT+&EM_NUM_INTERVAL_REJECTED);
18054 +    %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
18056 +        /*----- moved to pretrain ------------
18058 +        %EM_GETNAME(key=OUTDUMMY, type=DATA);
18059 +        %MakeDummyVariables( indata=&EM_IMPORT_DATA,
18060 +                             outvar=&EM_USER_OUTDUMMY,
18061 +                             outdata=_newtrainds,
18062 +                             fileref=&EM_FILE_EMFLOWSCORECODE,
18063 +                              ndummyvars=_ndummyvars
18064 +                            );
18066 +        %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
18067 +            %getNVarNObs(inds=_newtrainds, nvar=_nvar, nobs=_nobs);
18068 +            %if &_nobs > &VARCLUS_MAXNUMOBS  %then %do;
18069 +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning
18070 +                %goto endtrain;
18071 +            %end;
18072 +        %end;
18074 +        +---------------------------------------*/
18075 +        %if (%sysfunc(exist(_newtrainds)) or %sysfunc(exist(_newtrainds, VIEW))) < 1 %then %do;
18076 +        /*when there is no class var and &EM_PROPERTY_INCLUDECLASSVAR eq Y
18077 +          There is no _newtrainds */
18078 +        %MakeCorrelation(    indata=&EM_IMPORT_DATA,
18079 +                             outstat=&EM_USER_GOUTSTAT,
18080 +                             corrmatrix=Y,
18081 +                             outcorr=&EM_USER_GOUTCORR,
18082 +                             includeclassvar=N,
18083 +                             freq =%EM_FREQ
18084 +                          );
18085 +        %getInitialGClusterNumber(ninput=&_num_input_interval, ngc=_ngc);
18087 +        %end;
18088 +        %else %do;
18089 +         %MakeCorrelation(   indata=_newtrainds,
18090 +                             outstat=&EM_USER_GOUTSTAT,
18091 +                             corrmatrix=Y,
18092 +                             outcorr=&EM_USER_GOUTCORR,
18093 +                             includeclassvar=Y,
18094 +                             freq =%EM_FREQ
18095 +                          );
18096 +        %getInitialGClusterNumber(ninput=&_num_input_interval, ndummy=&_ndummyvars, ngc=_ngc);
18098 +        %end;
18100 +    %end;
18101 +    %else %do;
18103 +        /* moved to pretrain -------------------
18105 +         %if &EM_PROPERTY_SUPPRESSSAMPWARN eq N %then %do;
18106 +            %getNVarNObs(inds=&EM_IMPORT_DATA, nvar=_nvar, nobs=_nobs);
18107 +            %if &_nobs > &VARCLUS_MAXNUMOBS  %then %do;
18108 +                %let  EMEXCEPTIONSTRING = exception.server.varclus.sample.warning
18109 +                %goto endtrain;
18110 +            %end;
18111 +        %end;
18112 +         +------------------------------------------*/
18114 +        %MakeCorrelation( indata=&EM_IMPORT_DATA,
18115 +                          outstat=&EM_USER_GOUTSTAT,
18116 +                          corrmatrix=Y,
18117 +                          outcorr=&EM_USER_GOUTCORR,
18118 +                          includeclassvar=N,
18119 +                          freq =%EM_FREQ
18120 +                          );
18121 +        %getInitialGClusterNumber(ninput=&_num_input_interval, ngc=_ngc);
18122 +    %end;
18124 +   %UpdateOutStatCorrToDistance(indata=&EM_USER_GOUTSTAT, /* indata should be a outstat from proc varclus */
18125 +                                rsquare = N
18126 +                                );
18127 +   %HierClusWithCorr( indata=&EM_USER_GOUTSTAT ,
18128 +                      ncluster=&_ngc,
18129 +                      method = Ward,
18130 +                      outtree =&EM_USER_GOUTTREE,
18131 +                      idvar = _VAR_,
18132 +                      outdata=&EM_USER_GOUTGROUP,
18133 +                      rescore = N,
18134 +                      newncluster=_newnclus
18135 +                        );
18137 +   /* store the number of global cluster */
18139 +   data &EM_USER_VARCLUSMETA;
18140 +        set &EM_USER_VARCLUSMETA;
18141 +        NGCluster = &_newnclus;
18142 +   run;
18144 +   %MakeGobalConstellData(indata=&EM_USER_GOUTGROUP, outlink=&EM_USER_GOUTLINK, outnode=&EM_USER_GOUTNODE);
18146 +   %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
18147 +        %if (%sysfunc(exist(_newtrainds)) or %sysfunc(exist(_newtrainds, VIEW))) < 1 %then %do;
18148 +            %VarClus2(indata=&EM_IMPORT_DATA,
18149 +                 clusdata=&EM_USER_GOUTGROUP,
18150 +                 ngroup=&_newnclus);
18151 +         %end;
18152 +         %else %do;
18153 +             %VarClus2(indata=_newtrainds,
18154 +                 clusdata=&EM_USER_GOUTGROUP,
18155 +                 ngroup=&_newnclus);
18157 +         %end;
18159 +   %end;
18160 +   %else %do;
18161 +       %VarClus2(indata=&EM_IMPORT_DATA,
18162 +                 clusdata=&EM_USER_GOUTGROUP,
18163 +                 ngroup=&_newnclus);
18164 +   %end;
18166 +   %em_checkerror();
18167 +   %if &EMEXCEPTIONSTRING ne %then %do;
18168 +       %put &em_codebar;
18169 +       %put Error: Variable clustering failed.;
18170 +       %put &em_codebar;
18171 +       %goto endtrain2;
18172 +   %end;
18173 +   /*
18174 +    %FindClusNum(statds=&EM_USER_OUTSTAT, groupds=&EM_USER_OUTGROUP, minvariation=&EM_PROPERTY_MINVARIATION);
18175 +   */
18176 +   %endtrain2:
18177 +%mend Train2;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMUTIL.EM_COPYFILE.SOURCE.
18179 +%macro em_copyfile(infref=, outfref=, append=N);
18180 +
18181 +   %if %sysfunc(fileref(&infref))=0 and %sysfunc(fileref(&outfref))<=0 %then %do;
18182 +
18183 +       %let omode =;
18184 +       %if &append=Y %then
18185 +           %let omode = MOD;
18186 +       data _null_;
18187 +          length line $20000;
18188 +          file &outfref &omode lrecl=20000;
18189 +          fid=fopen("&infref",'i',20000,'v');
18190 +          if fid > 0  then do;
18191 +             do while(^fread(fid));
18192 +                rlen = frlen(fid);
18193 +                rc= fget(fid,line,20000);
18194 +                start = length(line)-length(left(line))+1;
18195 +                line=strip(line);
18196 +                put @start line;
18197 +             end;
18198 +             if fid > 0  then rc=fclose(fid);
18199 +          end;
18200 +       run;
18201 +
18202 +   %end;
18203 +%mend em_copyfile;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
18204  %let SYSCC = 0;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      4:40
NOTE: View EMWS2.IDS_DATA.VIEW used (Total process time):
      real time           0.07 seconds
      cpu time            0.07 seconds
 
NOTE: There were 48356 observations read from the data set DATA.CATALOG2010.
NOTE: There were 48356 observations read from the data set EMWS2.IDS_DATA.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.09 seconds
 
 
 
18205  %let SYSCC = 0;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set EMWS2.VARCLUS_VARCLUSMETA has 1 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: Clustering algorithm converged.
NOTE: View EMWS2.IDS_DATA.VIEW used (Total process time):
      real time           10.89 seconds
      cpu time            0.64 seconds
 
NOTE: There were 48356 observations read from the data set DATA.CATALOG2010.
NOTE: The data set EMWS2.VARCLUS_OUTTREE has 146 observations and 3 variables.
NOTE: The data set EMWS2.VARCLUS_OUTSTAT has 1732 observations and 89 variables.
NOTE: The PROCEDURE VARCLUS printed pages 2-6.
NOTE: PROCEDURE VARCLUS used (Total process time):
      real time           10.98 seconds
      cpu time            0.64 seconds
 
 
 
18206  %let SYSCC = 0;
NOTE: PROCEDURE DISPLAY used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      5:214
NOTE: There were 1732 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      7:15
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      7:9
NOTE: There were 1732 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORR has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORR.
NOTE: The data set WORK.CORR_TMP has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORR.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORR has 31 observations and 32 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORR.
NOTE: The data set WORK.CORR_TMP has 31 observations and 32 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORR.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORR has 31 observations and 32 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK.CORR_TMP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORR.
NOTE: The data set WORK._TMPCLUSRSQ has 31 observations and 32 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 31 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 961 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.02 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 961 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 961 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 961 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 930 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 930 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._NEXTCLUSRSQ has 31 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPCLUSRSQ (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      2:77
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      2:71
NOTE: There were 1732 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
NOTE: The data set WORK._TMPDS has 2 observations and 88 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2 observations read from the data set WORK._TMPDS.
NOTE: The data set WORK._OWNRSQ has 86 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      12:35
NOTE: Variable GCluster is uninitialized.
NOTE: There were 86 observations read from the data set WORK._OWNRSQ.
NOTE: The data set WORK._OWNRSQ has 86 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set WORK._OWNRSQ.
NOTE: The data set WORK._OWNRSQ has 86 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMPDS (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      4:40
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      4:34
NOTE: Variable GCluster is uninitialized.
NOTE: There were 1732 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSSTRUCT has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSSTRUCT.
NOTE: The data set WORK.CORR_TMP has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSSTRUCT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSSTRUCT has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK.CORR_TMP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSSTRUCT.
NOTE: The data set WORK._TMPCLUSRSQ has 31 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 31 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 2666 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2666 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 2666 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 2666 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 2580 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2580 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._TMPCLUSRSQ has 2580 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 2580 observations read from the data set WORK._TMPCLUSRSQ.
NOTE: The data set WORK._NEXTVARRSQ has 86 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK._TMPCLUSRSQ (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 86 observations read from the data set WORK._OWNRSQ.
NOTE: The data set WORK._OWNRSQ has 86 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 86 observations read from the data set WORK._NEXTVARRSQ.
NOTE: The data set WORK._NEXTVARRSQ has 86 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set WORK._OWNRSQ.
NOTE: There were 86 observations read from the data set WORK._NEXTVARRSQ.
NOTE: The data set EMWS2.VARCLUS_OUTRSQUARE has 86 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set WORK._NEXTCLUSRSQ.
NOTE: The data set WORK._NEXTCLUSRSQ has 31 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTRSQUARE has 86 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set WORK._NEXTCLUSRSQ.
NOTE: The data set WORK._NEXTCLUSRSQ has 31 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: There were 31 observations read from the data set WORK._NEXTCLUSRSQ.
NOTE: The data set EMWS2.VARCLUS_OUTRSQUARE has 117 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTRSQUARE has 117 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      50069:90
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      50069:84
NOTE: There were 1732 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORRPLOT has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set WORK.CORR_TMP has 31 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORRPLOT has 31 observations and 32 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: Deleting WORK.CORR_TMP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORRPLOT has 31 observations and 32 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORRPLOT has 961 observations and 3 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 961 observations read from the data set EMWS2.VARCLUS_OUTCLUSCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCLUSCORRPLOT has 961 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 3 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
      WHERE _type_ in ('MEAN', 'N', 'STD');
NOTE: The data set WORK.VARCLUS_TMP has 3 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 3 observations read from the data set WORK.VARCLUS_TMP.
NOTE: The data set EMWS2.VARCLUS_OUTSTATPLOT has 86 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTSTATPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTSTATPLOT has 86 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTSTATPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTSTATPLOT has 86 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK.VARCLUS_TMP (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
      WHERE _type_='CORR';
NOTE: The data set EMWS2.VARCLUS_OUTCORR has 86 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTCORR.
NOTE: The data set EMWS2.VARCLUS_OUTCORR has 86 observations and 87 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 86 observations read from the data set EMWS2.VARCLUS_OUTCORR.
NOTE: The data set EMWS2.VARCLUS_OUTCORRPLOT has 7396 observations and 4 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 7396 observations read from the data set EMWS2.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCORRPLOT has 7396 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 7396 observations read from the data set EMWS2.VARCLUS_OUTCORRPLOT.
      WHERE _LABEL_ not = ' ';
NOTE: The data set WORK.VARCLUS_MATCH has 7396 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      7:246
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 7396 observations read from the data set WORK.VARCLUS_MATCH.
NOTE: The data set WORK.VARCLUS_MATCH has 7396 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 7396 observations read from the data set EMWS2.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCORRPLOT has 7396 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This might cause unexpected results.
NOTE: MERGE statement has more than one data set with repeats of BY values.
NOTE: There were 7396 observations read from the data set WORK.VARCLUS_MATCH.
NOTE: There were 7396 observations read from the data set EMWS2.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCORRPLOT has 7396 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 7396 observations read from the data set EMWS2.VARCLUS_OUTCORRPLOT.
NOTE: The data set EMWS2.VARCLUS_OUTCORRPLOT has 7396 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: Deleting WORK.VARCLUS_MATCH (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTLINK has 117 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTNODE has 117 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1732 observations read from the data set EMWS2.VARCLUS_OUTSTAT.
NOTE: The data set EMWS2.VARCLUS_OUTSTATSCORE has 33 observations and 87 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file _FILE_ is:
      Filename=C:\Users\Kyle McLester\Desktop\dsba-6201\final-project\Workspaces\EMWS2\VarClus\EMFLOWSCORE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=13Apr2022:13:20:59,
      Create Time=13Apr2022:13:20:34
 
NOTE: 122 records were written to the file _FILE_.
      The minimum record length was 1.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.26 seconds
      cpu time            0.26 seconds
 
 
 
NOTE: The file _OUT is:
      Filename=C:\Users\Kyle McLester\Desktop\dsba-6201\final-project\Workspaces\EMWS2\VarClus\EMPUBLISHSCORE.sas,
      RECFM=V,LRECL=20000,File Size (bytes)=0,
      Last Modified=13Apr2022:13:20:59,
      Create Time=13Apr2022:13:20:34
 
NOTE: 122 records were written to the file _OUT.
      The minimum record length was 1.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Fileref _IN has been deassigned.
NOTE: Fileref _OUT has been deassigned.
18207  *------------------------------------------------------------*;
18208  * End TRAIN: VarClus;
18209  *------------------------------------------------------------*;
18210
 
18211  *------------------------------------------------------------*;
18212  * Close any missing semi colons;
18213  *------------------------------------------------------------*;
18214  ;
18215  ;
18216  ;
18217  ;
18218  quit;
18219  *------------------------------------------------------------*;
18220  * Close any unbalanced quotes;
18221  *------------------------------------------------------------*;
18222  /*; *"; *'; */
18223  ;
18224  run;
18225  quit;
18226  /* Reset EM Options */
18227  options formchar="|----|+|---+=|-/\<>*";
18228  options nocenter ls=256 ps=10000;
18229  goptions reset=all device=GIF NODISPLAY;
 
*------------------------------------------------------------*
* Score Log
Date:                April 13, 2022
Time:                13:20:59
*------------------------------------------------------------*
18331  %let EMEXCEPTIONSTRING=;
18332  *------------------------------------------------------------*;
18333  * SCORE: VarClus;
18334  *------------------------------------------------------------*;
18335  %let EM_ACTION = SCORE;
18336  %let syscc = 0;
18337
18338  %macro main;
18339
18340     filename temp catalog 'sashelp.emexpl.variableclustering_macros.source';
18341     %include temp;
18342     filename temp catalog 'sashelp.emexpl.variableclustering_macros2.source';
18343     %include temp;
18344     filename temp;
18345
18346    %SetProperties;
18347
18348     %if %upcase(&EM_ACTION) = CREATE %then %do;
18349         filename temp catalog 'sashelp.emexpl.variableclustering_create.source';
18350         %include temp;
18351         filename temp;
18352         %create;
18353     %end;
18354     %else
18355     %if %upcase(&EM_ACTION) = TRAIN %then %do;
18356          filename temp catalog 'sashelp.emexpl.variableclustering_train.source';
18357             %include temp;
18358             filename temp;
18359             %train;
18360     %end;
18361     %else
18362     %if %upcase(&EM_ACTION) = SCORE %then %do;
18363             filename temp catalog 'sashelp.emexpl.variableclustering_score.source';
18364             %include temp;
18365             filename temp;
18366             %score;
18367     %end;
18368     %else
18369     %if %upcase(&EM_ACTION) = REPORT %then %do;
18370             filename temp catalog 'sashelp.emexpl.variableclustering_report.source';
18371             %include temp;
18372             filename temp;
18373             %report;
18374     %end;
18375     /*
18376     %if %upcase(&EM_ACTION) = OPENTESTTABLE %then %do;
18377         %put 'OPENING TABLE';
18378     %end;
18379     %if %upcase(&EM_ACTION) = CLOSETESTTABLE %then %do;
18380         %put 'CLOSE TABLE';
18381     %end;
18382     */
18383  %mend main;
18384  %main;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS.SOURCE.
18385 +
18386 +/* Initialize property macro variables */
18387 +%macro SetProperties;
18388 +   %em_checkmacro(name=EM_PROPERTY_MAXCLUS,       global=Y, value=DEFAULT);
18389 +   %em_checkmacro(name=EM_PROPERTY_HIDEVARIABLE,  global=Y, value=Y);
18390 +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,   global=Y, value=SHORT);
18391 +   %em_checkmacro(name=EM_PROPERTY_CLUSSOURCE,    global=Y, value=CORR);
18392 +   %em_checkmacro(name=EM_PROPERTY_CLUSCOMP,      global=Y, value=PRINCIPAL);
18393 +   %em_checkmacro(name=EM_PROPERTY_CLUSHIERACHY,      global=Y, value=Y);
18394 +   %em_checkmacro(name=EM_PROPERTY_INCLUDECLASSVAR,      global=Y, value=N);
18395 +   %em_checkmacro(name=EM_PROPERTY_EXPORTEDCOMP,      global=Y, value=CLUSTERCOMP);
18396 +   %em_checkmacro(name=EM_PROPERTY_MAXEIGEN,         global=Y, value=DEFAULT);
18397 +   %em_checkmacro(name=EM_PROPERTY_PROPORTION,      global=Y, value=DEFAULT);
18398 +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,      global=Y, value=SHORT);
18399 +   %em_checkmacro(name=EM_PROPERTY_TWOSTAGECLUS,      global=Y, value=AUTO);
18400 +   %em_checkmacro(name=EM_PROPERTY_SUPPRESSSAMPWARN,      global=Y, value=N);
18401 +
18402 +%mend SetProperties;
18403 +
18404 +%Macro MakeDummyVariables(indata=,
18405 +                          outvar=,
18406 +                          outdata=,
18407 +                          fileref=,
18408 +                          recreatecmeta=N, /* optional */
18409 +                          incmeta=,     /* optional */
18410 +                          outcmeta=,    /* optional */
18411 +                          ndummyvars=_ndummyvars
18412 +                          );
18413 +    %global &ndummyvars;
18414 +
18415 +    proc dmdb batch data=&indata out=_dmdbdat dmdbcat=_dmdbcat classout=_classout;;
18416 +       class
18417 +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
18418 +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
18419 +    ;
18420 +    run;
18421 +    %let &ndummyvars = 0;
18422 +    data _null_;
18423 +    %let dsid = %sysfunc(open(work._classout));
18424 +      %let &ndummyvars = %sysfunc(attrn(&dsid, NOBS));
18425 +    %let dsid = %sysfunc(close(&dsid));
18426 +    run;
18427 +
18428 +    proc dmzip data=_dmdbdat dmdbcat=_dmdbcat;
18429 +       input
18430 +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
18431 +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
18432 +        / level=nominal stdize=no;
18433 +       make outvar = &outvar;
18434 +       score data = &indata out =&outdata;
18435 +       code  file=  "&fileref";
18436 +    run;
18437 +    %if &recreatecmeta eq Y %then %do;
18438 +    proc contents data =&outvar out=_tmpds(keep=NAME LABEL);
18439 +    data _tmpds;
18440 +        set _tmpds;
18441 +           ROLE = 'INPUT';
18442 +           LEVEL = 'INTERVAL';
18443 +           CREATOR='DMZIP';
18444 +           if NAME = '_TYPE_' then delete;
18445 +    run;
18446 +    data &outcmeta;
18447 +         set &incmeta _tmpds;
18448 +    run;
18449 +    %end;
18450 +    proc datasets lib=work nolist;
18451 +      delete  _dmdbdat _dmdbcat _classout
18452 +    %if &recreatecmeta eq Y %then %do;
18453 +    _tmpds
18454 +    %end;
18455 +    ;
18456 +    quit;
18457 +%Mend MakeDummyVariables;
18458 +
18459 +/*--- Determine Optimal Number of Cluster ----
18460 +%macro FindClusNum(statds=, groupds=, minvariation=);
18461 +   %global optnclus;
18462 +   data varclus_tmp(drop=_NAME_);
18463 +      set &statDs;
18464 +      where _type_ ='PROPOR';
18465 +   run;
18466 +   proc sort data=varclus_tmp;
18467 +      by _NCL_;
18468 +   run;
18469 +   proc transpose data=varclus_tmp out=varclus_tmp;
18470 +      by _NCL_;
18471 +      var %EM_INTERVAL_INPUT
18472 +      %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
18473 +      %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
18474 +      %let nvar = %sysfunc(attrn(&dsid, NVAR));
18475 +          %do i = 2 %to &nvar;
18476 +          %let varname = %sysfunc(varname(&dsid, &i));
18477 +          &varname
18478 +          %end;
18479 +      %end;
18480 +   ;
18481 +   run;
18482 +
18483 +   %if &minVariation eq %then %do;
18484 +       %let minVariation = &EM_PROPERTY_MINVARIATION;
18485 +   %end;
18486 +   %if ^(0<&minVariation<100) %then %do;
18487 +       %let minVariation = 90;
18488 +   %end;
18489 +
18490 +   data _null_;
18491 +      set varclus_tmp end=eof;
18492 +      by _NCL_;
18493 +      retain flag 0;
18494 +      if first._ncl_ then flag=0;
18495 +      if .<col1 < &minVariation then flag=1;
18496 +      if last._ncl_ and ^flag then do;
18497 +         call symput('OPTNCL', _ncl_);
18498 +         stop;
18499 +      end;
18500 +     if eof then call symput('OPTNCL', _ncl_);
18501 +   run;
18502 +
18503 +   %let optnclus = &OPTNCL;
18504 +
18505 +   data varclus_tmp(drop=_NCL_ _NAME_);
18506 +      set &statDs;
18507 +      where _type_ in('RSQUARED' 'GROUP') and _NCL_=&OPTNCL;
18508 +   run;
18509 +   proc sort data=varclus_tmp;
18510 +      by _TYPE_;
18511 +   run;
18512 +   proc transpose data=varclus_tmp out=varclus_tmp;
18513 +      by _TYPE_;
18514 +   run;
18515 +   proc sort data=varclus_tmp;
18516 +      by _name_ _type_;
18517 +   run;
18518 +
18519 +  proc transpose data=varclus_tmp out=&groupds;
18520 +      by _NAME_;
18521 +   run;
18522 +   proc sort data=&groupDs(rename=(col1=Cluster col2=Rsquare _NAME_=VARIABLE));
18523 +      by Cluster descending Rsquare;
18524 +      where Cluster ne 0;
18525 +   run;
18526 +   proc datasets lib=work nolist mt=(DATA VIEW);
18527 +      delete varclus_tmp;
18528 +   run;
18529 +   quit;
18530 +%mend findClusNum;
18531 +*/
18532 +
18533 +%macro getNclusfromTrain(inoutstat=, nc=);
18534 +%global &nc;
18535 +data _null_;
18536 +    set &inoutstat end=eof;
18537 +    if eof then do;
18538 +    call symput("&nc", _ncl_);
18539 +    end;
18540 +run;
18541 +%mend  getNclusfromTrain;
18542 +
18543 +%macro MakeDeltaCode(groupds=, outstatscore=, deltacodefile=);
18544 +
18545 +     *--- Build Code to Modify Metadata ---*;
18546 +     filename X "&deltacodefile";
18547 +     data _null_;
18548 +        FILE X;
18549 +        set &groupds end=eof;
18550 +        /*by Cluster;*/
18551 +         if _N_=1 then do;
18552 +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
18553 +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
18554 +           %end;
18555 +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
18556 +           put "if upcase(strip(NAME)) in (";
18557 +        end;
18558 +        if Strip(upcase(Selected)) eq 'YES' then do;
18559 +           string = '"'!!trim(left(VARIABLE))!!'"';
18560 +           put string;
18561 +        end;
18562 +        if eof then do;
18563 +           put ') then ROLE="INPUT";';
18564 +           put 'else ROLE="REJECTED";';
18565 +           put 'end;';
18566 +
18567 +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
18568 +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
18569 +           %end;
18570 +        end;
18571 +     run;
18572 +     quit;
18573 +
18574 +     filename X;
18575 +
18576 +     quit;
18577 +%mend MakeDeltaCode;
18578 +
18579 +%macro MakeVarClusCorrData(statds=, corrds=, corrplotds= );
18580 +    %if ^%sysfunc(exist(&statds)) %then %do;
18581 +         %goto doendc;
18582 +    %end;
18583 +
18584 +    data &corrds(drop=_TYPE_ _NCL_) ;
18585 +       set &statds;
18586 +       where _type_ eq 'CORR' ;
18587 +    run ;
18588 +    proc sort data=&corrds;
18589 +       by _NAME_ ;
18590 +    run ;
18591 +    proc transpose data=&corrds out=&corrplotds name=_TMP_;
18592 +      BY _NAME_ ;
18593 +    run ;
18594 +    data &corrplotds;
18595 +       length _Y_ $100;
18596 +       set &corrplotDs;
18597 +       if _LABEL_ ne '' then _Y_=_LABEL_ ; else _Y_=_TMP_ ;
18598 +    run ;
18599 +    data varclus_match(rename=(_TMP_= _NAME_ _LABEL_=_X_));
18600 +       set &corrplotds;
18601 +       where _LABEL_ ne '' ;
18602 +       keep _TMP_ _LABEL_ ;
18603 +    run ;
18604 +    data _null_;
18605 +       nobs=0;
18606 +       dsid = open('varclus_match');
18607 +       if dsid then do;
18608 +          nobs = attrn(dsid, 'NOBS');
18609 +          dsid = close(dsid);
18610 +       end;
18611 +       call symput ('CORR_NOBS', nobs);
18612 +    run;
18613 +    %if &corr_nobs %then %do;
18614 +        proc sort data=varclus_match;
18615 +           by _name_;
18616 +        run ;
18617 +        proc sort data=&corrplotds;
18618 +           by _name_;
18619 +        run ;
18620 +        data &corrplotds(keep= _X_ _Y_ col1 rename=(col1=Correlation)) ;
18621 +           merge varclus_match &corrplotds;
18622 +           by _NAME_ ;
18623 +           if _X_ eq '' then _X_=_NAME_ ;
18624 +           label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
18625 +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
18626 +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
18627 +
18628 +       run ;
18629 +    %end;
18630 +    %else %do;
18631 +        proc sort data=&corrplotds;
18632 +           by _name_;
18633 +        run ;
18634 +        data &corrplotds(keep= _NAME_ _Y_ col1 rename=(_NAME_=_X_ col1=Correlation)) ;
18635 +           set &corrplotds;
18636 +           label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
18637 +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
18638 +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
18639 +
18640 +        run ;
18641 +    %end;
18642 +    proc sort data=&corrplotds;
18643 +       by _X_ _Y_;
18644 +    run ;
18645 +    proc datasets lib=work nolist mt=(DATA VIEW);
18646 +       delete varclus_match;
18647 +    run;
18648 +    quit;
18649 +
18650 +%doendc:
18651 +
18652 +%mend MakeVarClusCorrData;
18653 +
18654 +%macro MakeStatPlotData(statds= , outstatplotds=);
18655 +   %if %sysfunc(exist(&statds)) %then %do;
18656 +
18657 +       data varclus_tmp(drop=_NAME_ _NCL_) ;
18658 +          set &statDs;
18659 +          where _type_ in('MEAN', 'STD', 'N');
18660 +       run ;
18661 +       proc transpose data=varclus_tmp out=&outstatplotds;
18662 +          id _TYPE_ ;
18663 +       run ;
18664 +       data &outstatplotds;
18665 +          set &outstatplotds(obs=1000);
18666 +          label _name_= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_name, noquote))";
18667 +          label _label_="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
18668 +          if MEAN ne 0 then SCALEDSTD= STD / MEAN ;
18669 +          else SCALEDSTD= STD ;
18670 +          label SCALEDSTD = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_scaledstd, noquote))";
18671 +       run ;
18672 +       proc sort data=&outstatplotds;
18673 +          by descending SCALEDSTD ;
18674 +       run ;
18675 +       proc datasets lib=work nolist mt=(DATA VIEW);
18676 +          delete varclus_tmp;
18677 +       run;
18678 +       quit;
18679 +    %end;
18680 +
18681 +%mend MakeStatPlotData;
18682 +
18683 +
18684 +%macro CreateScoreCode(indata=, ncluscomp=, fileref=);
18685 +     %EM_GETNAME(KEY=OUTSTATSCORE, type=DATA);
18686 +    data &EM_USER_OUTSTATSCORE;
18687 +          set &indata;
18688 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
18689 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
18690 +          if _TYPE_ = 'STD' then _NAME_='STD';
18691 +          DROP _TYPE_ _NCL_;
18692 +     run;
18693 +
18694 +     filename _file_  "&fileRef";
18695 +
18696 +     data _null_;
18697 +        FILE _file_ MOD;
18698 +        put ' ';
18699 +        put '/*-------------------------------------------------*/';
18700 +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_begin , noquote))" '*/';
18701 +        put '/*-------------------------------------------------*/';
18702 +        put ' ';
18703 +        %let dsid = %sysfunc(open(&EM_USER_OUTSTATSCORE));
18704 +
18705 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
18706 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
18707 +
18708 +        %let k = 1;
18709 +        %do %while(^%sysfunc(fetch(&dsid)));
18710 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
18711 +                %if &k > 2 %then %do;
18712 +                 %let cn = %eval(&k-2);
18713 +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_cluscompnum, noquote, &cn))"  "------ */";
18714 +                %end;
18715 +                %let k = %eval(&k+1);
18716 +        %end;
18717 +
18718 +        %let rc = %sysfunc(rewind(&dsid));
18719 +
18720 +        %do i= 2 %to &nvar;
18721 +            %let _varname =  %sysfunc(varname(&dsid, &i));
18722 +            %do %while(^%sysfunc(fetch(&dsid)));
18723 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
18724 +                %if &_name = MEAN %then
18725 +                %let _mean = %sysfunc(getvarn(&dsid, &i));
18726 +                %else %if &_name = STD %then
18727 +                %let _std = %sysfunc(getvarn(&dsid, &i));
18728 +                %else %do;
18729 +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
18730 +                      %let abscoeff = %sysfunc(abs(&coeff));
18731 +                          %if &abscoeff >  0 %then %do;
18732 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
18733 +                           %end;
18734 +                 %end;
18735 +             %end;
18736 +             %let rc = %sysfunc(rewind(&dsid));
18737 +         %end;
18738 +
18739 +        %let dsid= %sysfunc(close(&dsid));
18740 +       run;
18741 +%mend CreateScoreCode;
18742 +
18743 +
18744 +
18745 +/*----------------------------------------------------------
18746 +    Instead of using %MakeRSquareData,
18747 +    %MakeVarClusResultTable at macro2.source is used
18748 + +----------------------------------------------------------*/
18749 +
18750 +
18751 +%macro MakeRSquareData(indata=, inClusRSquare=, outdata=, ncluster=);
18752 +
18753 +/* modifying  from ods rsquare = data */
18754 +
18755 +data &outdata(drop= ControlVar  NumberOfClusters CurrentCluster);
18756 +    Length Cluster $16;
18757 +    length Variable $32;
18758 +    Length VariableLabel $64;
18759 +    set &indata; retain CurrentCluster;
18760 +    if NumberOfClusters ^= &ncluster then delete;
18761 +    if strip(Cluster) eq '' then Cluster = CurrentCluster;
18762 +    CurrentCluster = Cluster;
18763 +   run;
18764 +proc sort data =&outdata ;
18765 +     by Cluster RsquareRatio;
18766 +run;
18767 +data _tmprsq(drop=index);
18768 +     set &outdata; by Cluster;
18769 +     if first.Cluster then do;
18770 +     index = strip(scan(Cluster,2 ));
18771 +     Variable = "Clus"||index;
18772 +     VariableLabel = "Cluster Component "||index;
18773 +     OwnCluster = 1;
18774 +     NextClosest = .;
18775 +     RsquareRatio = 0;
18776 +     output;
18777 +     end;
18778 +run;
18779 +
18780 +proc sort data = _tmprsq ;
18781 +     by Cluster RsquareRatio;
18782 +run;
18783 +data &outdata;
18784 +     set &outdata _tmprsq;
18785 +by Cluster;
18786 +run;
18787 +
18788 +
18789 +/* Just create the Selected variable with all YES */
18790 +
18791 +data &outdata;
18792 +    set &outdata; by cluster;
18793 +    length Selected $8;
18794 +    Selected = 'YES';
18795 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
18796 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
18797 +    rename OwnCluster = RSqWithClusterComp;
18798 +    rename NextClosest = RSqWithNextClusComp;
18799 +run;
18800 +
18801 +
18802 +/* Selected = Y/N will be done %score section -----
18803 +
18804 +%if &EM_PROPERTY_EXPORTEDCOMP ne CLUSTERCOMP %then %do;
18805 +data &outdata;
18806 +    set &outdata; by cluster;
18807 +    length Selected $8;
18808 +    if first.Cluster then Selected = 'YES';
18809 +    else Selected = 'NO';
18810 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
18811 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
18812 +    rename OwnCluster = RSqWithClusterComp;
18813 +    rename NextClosest = RSqWithNextClusComp;
18814 +run;
18815 +%end;
18816 +%else %do;
18817 +data &outdata;
18818 +    set &outdata; by cluster;
18819 +    if last.Cluster then Selected = 'YES';
18820 +    else Selected = 'NO';
18821 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
18822 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
18823 +    rename OwnCluster = RSqWithClusterComp;
18824 +    rename NextClosest = RSqWithNextClusComp;
18825 +run;
18826 +%end;
18827 +---------------------------------------------------------------*/
18828 +
18829 +%if %sysfunc(exist(&inClusRSquare)) %then %do;
18830 +/* to calculate NextClosestClusRsq */
18831 +proc transpose data = &inClusRSquare  out=_clusRsq;
18832 +      by cluster;
18833 +      run;
18834 +data _clusRsq;
18835 +     set _clusRsq;
18836 +     if strip(upcase(Cluster)) eq strip(upcase(_NAME_)) then delete;
18837 +run;
18838 +
18839 +proc sort data=_clusRsq;
18840 +    by cluster col1;
18841 +    run;
18842 +data _clusRsq(drop=_NAME_ _LABEL_);
18843 +     set _clusRsq; by cluster;
18844 +     if last.Cluster then output;
18845 +     label  COL1 = 'R-Sqaure with Next Cluster Component';
18846 +     rename COL1 = RSqWithNextClusComp;
18847 +     rename Cluster = Variable;
18848 +     label  Cluster = "Variable";
18849 +run;
18850 +
18851 +proc sort data =&outdata;
18852 +     by Variable;
18853 +run;
18854 +data &outdata;
18855 +    merge &outdata _clusRsq;
18856 +    by Variable;
18857 +run;
18858 +proc sort data =&outdata;
18859 +by Cluster  RsquareRatio;
18860 +run;
18861 +quit;
18862 +%end;
18863 +
18864 +proc datasets lib = work nolist;
18865 +     delete _tmprsq _clusRsq;
18866 +     run;
18867 +quit;
18868 +
18869 +%mend MakeRSquareData;
18870 +
18871 +
18872 +/*-------------------------------------------------------------------------*/
18873 +
18874 +
18875 +
18876 +%macro ModifyCorr(indata=,
18877 +                  outdata=,
18878 +                  rsquare = Y
18879 +                  );
18880 +    data corr_tmp;
18881 +        set &indata;
18882 +    run;
18883 +     proc sql;
18884 +           update &indata
18885 +           set
18886 +     %let dsid = %sysfunc(open(work.corr_tmp));
18887 +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
18888 +          %do i = 4 %to &nvar;
18889 +          %let _name = %sysfunc(varname(&dsid, &i));
18890 +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
18891 +            %else  %let _name_md = &_name;
18892 +            %if &i < &nvar %then %do;
18893 +               &_name = 1- &_name_md ,
18894 +            %end;
18895 +            %else %do;
18896 +               &_name = &_name_md where _TYPE_ contains 'CORR' ;
18897 +            %end;
18898 +          %end;
18899 +      %let dsid= %sysfunc(close(&dsid));
18900 +
18901 +      select * from &indata;
18902 +      run;
18903 +      proc datasets lib = work nolist;
18904 +           delete corr_tmp;
18905 +      run;
18906 +      quit;
18907 +
18908 + %mend ModifyCorr;
18909 +
18910 + %macro MakeClusStructCorrData(indata=,outdata=, ncluster=, Rsquare=N);
18911 +    data &outdata(drop= _NCL_  _TYPE_);
18912 +       set &indata;
18913 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
18914 +       rename _NAME_ = Cluster;
18915 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
18916 +    run;
18917 +    %if &RSquare eq Y %then %do;
18918 +     data corr_tmp;
18919 +        set &outdata;
18920 +     run;
18921 +
18922 +     data &outdata(drop=i);
18923 +          set &outdata;
18924 +          %let dsid = %sysfunc(open(work.corr_tmp));
18925 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
18926 +          %do i = 2 %to &nvar;
18927 +            %let _name = %sysfunc(varname(&dsid, &i));
18928 +            %let _name_md = &_name.**2;
18929 +                &_name = &_name_md;
18930 +          %end;
18931 +      %let dsid= %sysfunc(close(&dsid));
18932 +      run;
18933 +      proc datasets lib = work nolist;
18934 +           delete corr_tmp;
18935 +      run;
18936 +
18937 +    %end;
18938 +     quit;
18939 +%mend MakeClusStructCorrData;
18940 +
18941 +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, RSquare=N, makeplotds=N, plotds=);
18942 +    data &outdata(drop= _NCL_  _TYPE_);
18943 +       set &indata;
18944 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
18945 +       rename _NAME_ = Cluster;
18946 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
18947 +    run;
18948 +    data corr_tmp;
18949 +        set &outdata;
18950 +    run;
18951 +
18952 +    %let dsid = %sysfunc(open(work.corr_tmp));
18953 +    %let nclus2= %eval(&ncluster+1);
18954 +    data &outdata;
18955 +         set &outdata;
18956 +          %do i = 2 %to &nclus2;
18957 +          %let i_1 = %eval(&i-1);
18958 +            %let _name = %sysfunc(varname(&dsid, &i));
18959 +            %let _newName = Clus&i_1;
18960 +                rename &_name = &_newName; ;
18961 +                *label &_name ="Cluster &i_1";
18962 +                label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
18963 +          %end;
18964 +          keep Cluster
18965 +          %do i = 2 %to &nclus2;
18966 +                %let _name = %sysfunc(varname(&dsid, &i));
18967 +                &_name
18968 +          %end;
18969 +          ;
18970 +    %let dsid= %sysfunc(close(&dsid));
18971 +     run;
18972 +     quit;
18973 +
18974 +    %if &RSquare eq Y %then %do;
18975 +
18976 +       data corr_tmp;
18977 +        set &outdata;
18978 +     run;
18979 +
18980 +     data &outdata(drop=i);
18981 +          set &outdata;
18982 +          %let dsid = %sysfunc(open(work.corr_tmp));
18983 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
18984 +          %do i = 2 %to &nvar;
18985 +            %let _name = %sysfunc(varname(&dsid, &i));
18986 +            %let _name_md = &_name.**2;
18987 +                &_name = &_name_md;
18988 +          %end;
18989 +      %let dsid= %sysfunc(close(&dsid));
18990 +      run;
18991 +    %end;
18992 +
18993 +    %if &makeplotds eq Y %then %do;
18994 +     proc transpose data = &outdata
18995 +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
18996 +          by cluster;
18997 +     run;
18998 +     data &plotds;
18999 +          set  &plotds;
19000 +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
19001 +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
19002 +     run;
19003 +     %end;
19004 +     proc datasets lib = work nolist;
19005 +           delete corr_tmp;
19006 +     run;
19007 +     quit;
19008 +%mend MakeInterClusCorrData;
19009 +
19010 +
19011 +%macro MakeClusConstellData(indata=, outlink=, outnode=);
19012 +
19013 +data &outlink(drop = Selected);
19014 +     set &indata;
19015 +     LINKID = _N_;
19016 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
19017 +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
19018 +run;
19019 +data &outnode(keep=NODEID TYPE LABEL);
19020 +    set &indata;
19021 +    length TYPE $16;
19022 +    rename Variable = NODEID;
19023 +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
19024 +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
19025 +    then  TYPE = "CLUSTER";
19026 +    else  TYPE="VARIABLE";
19027 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
19028 +run;
19029 +quit;
19030 +%mend MakeClusConstellData;
19031 +
19032 +
19033 +
19034 +%macro MakeClusConstellData(indata=, outlink=, outnode=);
19035 +
19036 +data &outlink(drop = Selected);
19037 +     set &indata;
19038 +     LINKID = _N_;
19039 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
19040 +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
19041 +run;
19042 +data &outnode(keep=NODEID TYPE LABEL);
19043 +    set &indata;
19044 +    length TYPE $16;
19045 +    rename Variable = NODEID;
19046 +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
19047 +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
19048 +    then  TYPE = "CLUSTER";
19049 +    else  TYPE="VARIABLE";
19050 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
19051 +run;
19052 +quit;
19053 +%mend MakeClusConstellData;
19054 +
19055 +
19056 +/*--- This will work only when inds is not a view data -------
19057 +
19058 +%macro getNVarNObs(inds=, nvar=, nobs=);
19059 +
19060 +    %global &nvar;
19061 +    %global &nobs;
19062 +    data _null_;
19063 +         dsid = open("&inds");
19064 +         nv = attrn(dsid, 'NVAR');
19065 +         no = attrn(dsid, 'NOBS');
19066 +         dsid = close(dsid);
19067 +         call symput("&nvar", nv);
19068 +         call symput("&nobs", no);
19069 +    run;
19070 +    quit;
19071 +%mend  getNVarNObs;
19072 +
19073 ++---------------------------------------------------------------*/
19074 +
19075 +
19076 +%macro getNVar(inds=, nvar=);
19077 +    %global &nvar;
19078 +    data _null_;
19079 +         dsid = open("&inds");
19080 +         nv = attrn(dsid, 'NVAR');
19081 +         dsid = close(dsid);
19082 +         call symput("&nvar", nv);
19083 +    run;
19084 +    quit;
19085 +%mend  getNVar;
19086 +
19087 +
19088 +
19089 +%macro getNObs(inds=, nobs=);
19090 +    %global &nobs;
19091 +    data _null_;
19092 +        set &inds end=eof;
19093 +        if eof then call symput("&nobs", _N_);
19094 +    run;
19095 +    quit;
19096 +%mend  getNObs;
19097 +
19098 +%Macro CreateVarclusMeta(trainnum=);
19099 +   %EM_GETNAME(KEY=VARCLUSMETA, TYPE=DATA);
19100 +    data &EM_USER_VARCLUSMETA;
19101 +         length TrainNum 8.;
19102 +         length NewTrain $8;
19103 +         length NGCluster 8.;
19104 +         length ExportedComp $16;
19105 +         length HideVariable $8;
19106 +         TrainNum = &trainnum;
19107 +         NewTrain = "Y";
19108 +         ExportedComp = "&EM_PROPERTY_EXPORTEDCOMP";
19109 +         HideVariable = "&EM_PROPERTY_HIDEVARIABLE";
19110 +         NGCluster = 0; /* zero means no twostage */
19111 +   run;
19112 +   quit;
19113 +%mend CreateVarclusMeta;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS2.SOURCE.
19114 +
19115 +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, globalclusid=, RSquare=N, makeplotds=N, plotds=);
19116 +    data &outdata(drop= _NCL_  _TYPE_);
19117 +       set &indata;
19118 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
19119 +       %if &globalclusid ne %then %do;
19120 +       _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
19121 +       rename _NAME_ = Cluster;
19122 +       %end;
19123 +       %else %do;
19124 +        _NAME_ = upcase(_NAME_);
19125 +       rename _NAME_ = Cluster;
19126 +       %end;
19127 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
19128 +    run;
19129 +    data corr_tmp;
19130 +        set &outdata;
19131 +    run;
19132 +
19133 +    %let dsid = %sysfunc(open(work.corr_tmp));
19134 +    %let nclus2= %eval(&ncluster+1);
19135 +    data &outdata;
19136 +         set &outdata;
19137 +          %do i = 2 %to &nclus2;
19138 +          %let i_1 = %eval(&i-1);
19139 +            %let _name = %sysfunc(varname(&dsid, &i));
19140 +            %if &globalclusid ne %then
19141 +                %do; %let _newName = GC&globalclusid._CLUS&i_1;
19142 +                     rename &_name = &_newName;
19143 +                     *label &_name ="GC &globalclusid : Cluster &i_1";
19144 +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gc_clusternum, noquote,  &globalclusid, &i_1))";
19145 +                %end;
19146 +            %else
19147 +                %do; %let _newName = CLUS&i_1;
19148 +                     rename &_name = &_newName;
19149 +                     *label &_name ="Cluster &i_1";
19150 +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
19151 +                %end;
19152 +          %end;
19153 +          keep Cluster
19154 +          %do i = 2 %to &nclus2;
19155 +                %let _name = %sysfunc(varname(&dsid, &i));
19156 +                &_name
19157 +          %end;
19158 +          ;
19159 +    %let dsid= %sysfunc(close(&dsid));
19160 +     run;
19161 +     quit;
19162 +
19163 +    %if &RSquare eq Y %then %do;
19164 +
19165 +       data corr_tmp;
19166 +        set &outdata;
19167 +     run;
19168 +
19169 +     data &outdata;
19170 +          set &outdata;
19171 +          %let dsid = %sysfunc(open(work.corr_tmp));
19172 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
19173 +          %do i = 2 %to &nvar;
19174 +            %let _name = %sysfunc(varname(&dsid, &i));
19175 +            %let _name_md = &_name.**2;
19176 +                &_name = &_name_md;
19177 +          %end;
19178 +      %let dsid= %sysfunc(close(&dsid));
19179 +      run;
19180 +    %end;
19181 +
19182 +    %if &makeplotds eq Y %then %do;
19183 +     proc transpose data = &outdata
19184 +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
19185 +          by cluster;
19186 +     run;
19187 +     data &plotds;
19188 +          set  &plotds;
19189 +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
19190 +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
19191 +          label  Correlation="%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
19192 +     run;
19193 +     %end;
19194 +     proc datasets lib = work nolist;
19195 +           delete corr_tmp;
19196 +     run;
19197 +     quit;
19198 +%mend MakeInterClusCorrData;
19199 +
19200 +%macro MakeOwnRSquare(indata=, outdata=, ncluster=, globalclusid=);
19201 +    data _tmpds(drop= _NCL_);
19202 +       set &indata;
19203 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) in ('GROUP','RSQUARED')) then delete;
19204 +       %if &globalclusid ne %then %do;
19205 +           _NAME_ = "GC&globalclusid.";
19206 +       rename _NAME_ = Cluster;
19207 +       %end;
19208 +       %else %do;
19209 +        _NAME_ = "CLUS";
19210 +        rename _NAME_ = Cluster;
19211 +       %end;
19212 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
19213 +    run;
19214 +    proc transpose data =_tmpds out =&outdata;
19215 +    run;
19216 +
19217 +    data &outdata(drop=COL1);
19218 +        %if &globalclusid ne %then %do;
19219 +        length GCluster $16;
19220 +        %end;
19221 +        length Cluster $32;
19222 +        length _NAME_ $32;
19223 +         set &outdata;
19224 +         _NAME_ = upcase(_NAME_);
19225 +         rename _NAME_=Variable;
19226 +         *label _NAME_="Variable";
19227 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
19228 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
19229 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
19230 +
19231 +         %if &globalclusid ne %then %do;
19232 +          GCluster = "GC&globalclusid";
19233 +          Cluster = "GC&globalclusid._CLUS"||strip(COL1);
19234 +         %end;
19235 +         %else %do;
19236 +         Cluster = "CLUS"||strip(COL1);
19237 +        %end;
19238 +         rename COL2 = RSqWithOwnClusComp;
19239 +         *label COL2 = "R-Square With Own Cluster Component";
19240 +         label COL2 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
19241 +
19242 +   run;
19243 +   proc sort data =&outdata;
19244 +        by Cluster RSqWithOwnClusComp;
19245 +   run;
19246 +   proc datasets lib = work nolist;
19247 +           delete _tmpds;
19248 +   run;
19249 +   quit;
19250 +%mend MakeOwnRSquare;
19251 +
19252 +%macro MakeClusStructCorrData(indata=, outdata=, globalclusid=, ncluster=, Rsquare=N);
19253 +    data &outdata(drop= _NCL_  _TYPE_);
19254 +       %if &globalclusid ne %then %do;
19255 +        length GCluster $16;
19256 +        %end;
19257 +       set &indata;
19258 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
19259 +       %if &globalclusid ne %then %do;
19260 +         GCluster = "GC&globalclusid";
19261 +         _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
19262 +         rename _NAME_ = Cluster;
19263 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
19264 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
19265 +
19266 +       %end;
19267 +       %else %do;
19268 +         _NAME_ = upcase(_NAME_);
19269 +         rename _NAME_ = Cluster;
19270 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
19271 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
19272 +
19273 +       %end;
19274 +     run;
19275 +    %if &RSquare eq Y %then %do;
19276 +     data corr_tmp;
19277 +          set &outdata;
19278 +     run;
19279 +     %let istart = 2;
19280 +     %if &globalclusid ne %then %let istart = 3;
19281 +     data &outdata;
19282 +          set &outdata;
19283 +          %let dsid = %sysfunc(open(work.corr_tmp));
19284 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
19285 +          %do i =&istart %to &nvar;
19286 +            %let _name = %sysfunc(varname(&dsid, &i));
19287 +            %let _name_md = &_name.**2;
19288 +                &_name = &_name_md;
19289 +          %end;
19290 +      %let dsid= %sysfunc(close(&dsid));
19291 +      run;
19292 +      proc datasets lib = work nolist;
19293 +           delete corr_tmp;
19294 +      run;
19295 +    %end;
19296 +     quit;
19297 +%mend MakeClusStructCorrData;
19298 +
19299 +/*
19300 +%MakeClusStructCorrData(indata=playpen._outstat, outdata=_structrsq , ncluster=7, Rsquare=Y);
19301 +*/
19302 +
19303 +%macro FindNextClosestClusByVar(indata=, outdata=, globalclusid=, ncluster=);
19304 +
19305 +     /* The indata should be the outdata
19306 +        from %MakeClusStructCorrData(indata=, outdata=, ); */
19307 +
19308 +     proc sort data =&indata out=_tmpclusRsq;
19309 +     by cluster;
19310 +     run;
19311 +
19312 +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
19313 +      by cluster;
19314 +     run;
19315 +
19316 +     proc sort data=_tmpclusRsq;
19317 +        by _NAME_ COL1;
19318 +     run;
19319 +
19320 +     data _tmpclusRsq;
19321 +         length _NAME_ $32;
19322 +         set _tmpclusRsq; by _NAME_;
19323 +          _NAME_ = upcase(_NAME_);
19324 +          %if &ncluster ne 1 %then %do;
19325 +             if last._NAME_ then delete;
19326 +          %end;
19327 +          %else %do;
19328 +             COL1 = 0;
19329 +          %end;
19330 +     run;
19331 +     /* need to sort again */
19332 +     proc sort data=_tmpclusRsq;
19333 +        by _NAME_ COL1;
19334 +     run;
19335 +
19336 +     data &outdata;
19337 +         set _tmpclusRsq; by _NAME_;
19338 +         Cluster = upcase(Cluster);
19339 +         if last._NAME_ then output;
19340 +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
19341 +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
19342 +         rename COL1 = RSqWithNextClusComp;
19343 +         Cluster = upcase(Cluster);
19344 +         rename Cluster = ClosestCluster;
19345 +         *label  Cluster = "Next Closest Cluster";
19346 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
19347 +         rename _NAME_ = Variable;
19348 +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
19349 +    run;
19350 +
19351 +
19352 +    %if &globalclusid ne %then %do;
19353 +    data &outdata;
19354 +       length GCluster $16;
19355 +       set &outdata;
19356 +       GCluster = "GC&globalclusid";
19357 +       run;
19358 +    %end;
19359 +    proc datasets lib = work nolist;
19360 +           delete _tmpclusRsq;
19361 +    run;
19362 +    quit;
19363 +%mend FindNextClosestClusByVar;
19364 +
19365 +
19366 +%macro FindNextClosestClusByCluster(indata=, outdata=, globalclusid=, ncluster=);
19367 +     /* The indata should be the outdata from %MakeInterClusCorrData(indata=, outdata=, ); */
19368 +     proc sort data =&indata out=_tmpclusRsq;
19369 +     by cluster;
19370 +     run;
19371 +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
19372 +     by cluster;
19373 +     run;
19374 +     proc sort data=_tmpclusRsq;
19375 +        by _NAME_ col1;
19376 +     run;
19377 +     data _tmpclusRsq;
19378 +         length _NAME_ $32;
19379 +         set _tmpclusRsq; by _NAME_;
19380 +          _NAME_ = upcase(_NAME_);
19381 +          %if &ncluster ne 1 %then %do;
19382 +             if last._NAME_ then delete;
19383 +          %end;
19384 +          %else %do;
19385 +             COL1 = 0;
19386 +          %end;
19387 +     run;
19388 +     data &outdata;
19389 +         set _tmpclusRsq; by _NAME_;
19390 +         Cluster = upcase(Cluster);
19391 +         if last._NAME_ then output;
19392 +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
19393 +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
19394 +         rename COL1 = RSqWithNextClusComp;
19395 +         Cluster = upcase(Cluster);
19396 +         rename Cluster = ClosestCluster;
19397 +         *label  Cluster = "Next Closest Cluster";
19398 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
19399 +         rename _NAME_ = Variable;
19400 +         *label  _NAME_ = "Variable";
19401 +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
19402 +
19403 +    run;
19404 +    %if &globalclusid ne %then %do;
19405 +    data &outdata;
19406 +       length GCluster $16;
19407 +       set &outdata;
19408 +       GCluster = "GC&globalclusid";
19409 +       run;
19410 +    %end;
19411 +
19412 +    proc datasets lib = work nolist;
19413 +           delete _tmpclusRsq;
19414 +    run;
19415 +
19416 +    quit;
19417 +%mend FindNextClosestClusByCluster;
19418 +
19419 +%macro MakeVarClusResultTable(indata1=, indata2=, indata3=, outdata=, globalclusid=, ncluster=, selectedcomp=clustercomp);
19420 +/*----
19421 +  indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq,
19422 +-----------*/
19423 +
19424 +proc sort data =&indata1;
19425 +    by Variable;
19426 +run;
19427 +proc sort data =&indata2;
19428 +    by Variable;
19429 +run;
19430 +data &outdata;
19431 +    merge &indata1 &indata2;
19432 +    by Variable;
19433 +    length Type $16;
19434 +    Type = 'Variable';
19435 +    *label Type ='Type';
19436 +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
19437 +run;
19438 +
19439 +
19440 +data &indata3;
19441 +    set  &indata3 ;
19442 +    length RSqWithOwnClusComp 8.;
19443 +    Cluster = Variable;
19444 +    RSqWithOwnClusComp = 1;
19445 +    *label RSqWithOwnClusComp = "R-Square With Own Cluster Component";
19446 +    label RSqWithOwnClusComp = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
19447 +    length Type $16;
19448 +    Type = 'ClusterComp';
19449 +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
19450 +
19451 +;
19452 +run;
19453 +
19454 +proc sort data=&outdata;
19455 +    by Cluster;
19456 +run;
19457 +proc sort data =&indata3;
19458 +    by Cluster;
19459 +run;
19460 +
19461 +data &outdata;
19462 +     set &outdata &indata3;
19463 +     by Cluster;
19464 +run;
19465 +
19466 +
19467 +/* Create the Selected variable with all YES */
19468 +
19469 +data &outdata;
19470 +     set &outdata;
19471 +     length RsqRatio 8.;
19472 +     length Selected $8;
19473 +     *label RSqRatio = "1-R**2 Ratio";
19474 +     label RSqRatio =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_oneminusrsq, noquote))" ;
19475 +     *label Selected = "Variable Selected";
19476 +     label Selected = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_varselected, noquote))" ;
19477 +     RsqRatio = (1-RSqWithOwnClusComp)/(1-RSqWithNextClusComp);
19478 +     Selected ='YES';
19479 +     rename _LABEL_ = Label;
19480 +     label _LABEL_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
19481 +run;
19482 +
19483 +
19484 +/*----  Selected = Y/N will be assigened at the %score                   -------+
19485 +        Just create the Selected variable with all YES at the step above
19486 + +------------------------------------------------------------------------------+
19487 +
19488 +proc sort data=&outdata;
19489 +    by Cluster RsqRatio;
19490 +run;
19491 +
19492 +%if &selectedcomp eq CLUSTERCOMP %then %do;
19493 +data &outdata;
19494 +     set &outdata; by Cluster;
19495 +     length Selected $8;
19496 +     label Selected = "Variable Selected";
19497 +     if  first.Cluster then Selected ='Yes';
19498 +     else Selected = 'No';
19499 +    run;
19500 +%end;
19501 +%else %do;
19502 +data &outdata(drop = _var _varchange);
19503 +     set &outdata; retain _var 0; by Cluster;
19504 +     length Selected $8;
19505 +     label Selected = "Variable Selected";
19506 +     if first.Cluster then  _varchange = 0;
19507 +     else _varchange =1;
19508 +     if _var ne _varchange then  Selected  = 'Yes';
19509 +     else Selected = 'No';
19510 +     if last.cluster then  _var = 0;
19511 +     else _var = _varchange;
19512 +run;
19513 +%end;
19514 +
19515 +--------------------------------------------------------------*/
19516 +
19517 +quit;
19518 +%mend MakeVarClusResultTable;
19519 +
19520 +%Macro MakePlotDataFromCorrTable(indata=, outdata=, globalclusid=);
19521 +     proc sort data =&indata;
19522 +        by cluster;
19523 +     run;
19524 +     proc transpose data =&indata
19525 +          out=&outdata(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
19526 +          by cluster;
19527 +     run;
19528 +     data &outdata;
19529 +          set  &outdata;
19530 +          label x= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
19531 +          label Y= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
19532 +          label Correlation = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))" ;
19533 +     run;
19534 +     %if &globalclusid ne %then %do;
19535 +     data &outdata;
19536 +          Length GCluster $16;
19537 +          label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
19538 +          set  &outdata;
19539 +          GCluster ="GC&globalclusid.";
19540 +          run;
19541 +     %end;
19542 +
19543 +%Mend MakePlotDataFromCorrTable;
19544 +
19545 +
19546 +%macro MakeCorrelation(indata=,
19547 +                       outstat=_tmpoutstat,
19548 +                       corrmatrix=N,
19549 +                       outcorr=_tmpoutcorr,
19550 +                       includeclassvar=N,
19551 +                       target=,
19552 +                       freq=,
19553 +                       weight=);
19554 +   %if &target eq  %then %do;
19555 +
19556 +       proc varclus data=&indata outstat=&outstat hi maxclusters=1 noprint;
19557 +            var %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED
19558 +       %if &includeclassvar eq Y %then %do;
19559 +          %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
19560 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
19561 +          %do i = 2 %to &nvar;
19562 +          %let varname = %sysfunc(varname(&dsid, &i));
19563 +          &varname
19564 +          %end;
19565 +       %end;
19566 +       ;
19567 +      %if &freq ne  %then %do;
19568 +          freq &freq;
19569 +      %end;
19570 +      %if &weight ne  %then %do;
19571 +          weight &weight;
19572 +      %end;
19573 +
19574 +      run;
19575 +      %if &corrmatrix eq Y %then %do;
19576 +      data  &outcorr (drop = _NCL_ _TYPE_);
19577 +           set  &outstat ;
19578 +           if _TYPE_ ='CORR' then output;
19579 +      run;
19580 +      %end;
19581 +    %end;
19582 +    %else %do;
19583 +       proc corr data=&indata outp=&outstat noprint;
19584 +            var
19585 +       %let dsid = %sysfunc(open(&indata));
19586 +       %let nvar = %sysfunc(attrn(&dsid, NVAR));
19587 +          %do i = 1 %to &nvar;
19588 +              %let _name = %sysfunc(varname(&dsid, &i));
19589 +              %if &_name ne &target %then;
19590 +              &_name
19591 +           %end;
19592 +        %let dsid= %sysfunc(close(&dsid));
19593 +        ;
19594 +        with &target;
19595 +        run;
19596 +    %end;
19597 +    quit;
19598 +%mend MakeCorrelation;
19599 +
19600 +
19601 +%macro MakeCorrelationDistance(indata=,
19602 +                               outdata=,
19603 +                               rsquare = N
19604 +                               );
19605 +    data corr_tmp;
19606 +        set &indata;
19607 +        if _N_ = 1 then do;
19608 +           output;
19609 +           stop;
19610 +         end;
19611 +    run;
19612 +    %if &outdata ne  %then %let  _outdata = &outdata;
19613 +    %else %let _outdata = &indata;
19614 +
19615 +    data &_outdata;
19616 +         set &indata;
19617 +
19618 +         %let dsid = %sysfunc(open(work.corr_tmp));
19619 +         %let nvar = %sysfunc(attrn(&dsid, NVAR));
19620 +          %do i = 2 %to &nvar;
19621 +              %let _name = %sysfunc(varname(&dsid, &i));
19622 +              %if &rsquare eq Y %then %let _name_md = &_name.**2;
19623 +              %else  %let _name_md = &_name;
19624 +              &_name = 1- &_name_md;
19625 +          %end;
19626 +      %let dsid= %sysfunc(close(&dsid));
19627 +      run;
19628 +      proc datasets lib = work nolist;
19629 +           delete corr_tmp;
19630 +      run;
19631 +      quit;
19632 +  %mend MakeCorrelationDistance;
19633 +
19634 +
19635 +%macro UpdateOutStatCorrToDistance(indata=, /* indata should be a outstat from proc varclus */
19636 +                                   rsquare = N
19637 +                                   );
19638 +    data corr_tmp;
19639 +        set &indata;
19640 +    run;
19641 +    proc sql noprint;
19642 +           update &indata
19643 +           set
19644 +     %let dsid = %sysfunc(open(work.corr_tmp));
19645 +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
19646 +          %do i = 4 %to &nvar;
19647 +          %let _name = %sysfunc(varname(&dsid, &i));
19648 +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
19649 +            %else  %let _name_md = &_name;
19650 +            %if &i < &nvar %then %do;
19651 +               &_name = 1- &_name_md ,
19652 +            %end;
19653 +            %else %do;
19654 +               &_name = &_name_md where _TYPE_ eq 'CORR' ;
19655 +            %end;
19656 +          %end;
19657 +      %let dsid= %sysfunc(close(&dsid));
19658 +
19659 +      select * from &indata;
19660 +      run;
19661 +     data &indata( drop = _NCL_);
19662 +           set &indata;
19663 +           if _TYPE_ not in ('CORR', 'STD', 'N', 'MEAN') then delete;
19664 +           if _TYPE_ ='CORR' then _TYPE_ ='DISTANCE';
19665 +     run;
19666 +     data &indata(DROP = _NCL_);
19667 +           set &indata;
19668 +           if _TYPE_ = 'CORR' then _TYPE_ ='DISTANCE';
19669 +           if _TYPE_ not in ('DISTANCE', 'N', 'STD', 'MEAN') then delete;
19670 +           rename _NAME_ = _VAR_;
19671 +     run;
19672 +     proc datasets lib = work nolist;
19673 +           delete corr_tmp;
19674 +     run;
19675 +     quit;
19676 + %mend UpdateOutStatCorrToDistance;
19677 +
19678 +
19679 +%macro HierClusWithCorr(indata= ,
19680 +                        ncluster=,
19681 +                        method = Ward,
19682 +                        outtree = _outtree,
19683 +                        idvar =_VAR_,
19684 +                        outdata=,
19685 +                        rescore = N,
19686 +                        newncluster=
19687 +                        );
19688 +      %global &newncluster;
19689 +      %if &rescore ne Y %then %do;
19690 +      proc cluster data=&indata(type=Distance where=(upcase(strip(_TYPE_)) = "DISTANCE"))
19691 +                   method=&method outtree=&outtree noprint;
19692 +           id &idvar;
19693 +      run;
19694 +      %end;
19695 +      proc tree data=&outtree nclusters = &ncluster out=&outdata noprint;
19696 +      run;
19697 +      /* ----- Check some variables like CL1, CL5..., remove them ----*/
19698 +      proc contents data =&indata out=_outcontent(keep=NAME) noprint;
19699 +      run;
19700 +      data _outcontent;
19701 +          set _outcontent;
19702 +          if NAME in ('_TYPE_' , '_VAR_') then delete;
19703 +          index = 1;
19704 +          rename NAME = _NAME_;
19705 +      run;
19706 +      proc sort data=_outcontent;
19707 +          by _NAME_;
19708 +      run;
19709 +      proc sort data =&outdata;
19710 +           by _NAME_;
19711 +      run;
19712 +      data &outdata(drop=index);
19713 +          merge &outdata _outcontent;
19714 +          by _NAME_;
19715 +          if index = . then delete;
19716 +      run;
19717 +      /*-----------------------------------------------------------*/
19718 +      data &outdata;
19719 +           length CLUSNAME $16;
19720 +           set &outdata;
19721 +           if CLUSTER > &ncluster then delete;
19722 +           CLUSNAME='GC'||strip(CLUSTER);
19723 +           *label CLUSNAME = "Cluster Name";
19724 +           label CLUSNAME  = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername, noquote))" ;
19725 +           rename _NAME_ = VARIABLE ;
19726 +           *label _NAME_ = "Variable";
19727 +           *label CLUSTER = "Cluster";
19728 +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
19729 +           label CLUSTER ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
19730 +      run;
19731 +      proc sort data=&outdata out=&outdata;
19732 +           by CLUSTER;
19733 +      run;
19734 +      proc means data =&outdata noprint;
19735 +           output out=_meanout;
19736 +      run;
19737 +      data _null_;
19738 +            set _meanout;
19739 +            if strip(_STAT_) eq 'MAX' then do;
19740 +            call symput("&newncluster", CLUSTER);
19741 +            stop;
19742 +            end;
19743 +      run;
19744 +
19745 +      proc datasets lib = work nolist;
19746 +           delete _outcontent _meanout;
19747 +      run;
19748 +      quit;
19749 +%mend  HierClusWithCorr;
19750 +
19751 +%macro CreateScoreCode2(indata=, ncluscomp=, globalclusid=, fileref=);
19752 +
19753 +     data _tmpindata;
19754 +          set &indata;
19755 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
19756 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
19757 +          if _TYPE_ = 'STD' then _NAME_='STD';
19758 +          if _TYPE_ = 'SCORE' then _NAME_=upcase("GC&globalclusid._"||_NAME_);
19759 +          DROP _TYPE_ _NCL_;
19760 +     run;
19761 +
19762 +     filename _file_  "&fileRef";
19763 +
19764 +     data _null_;
19765 +        FILE _file_ MOD;
19766 +        put ' ';
19767 +        put "/*-------------------------------------------------*/";
19768 +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_gclus, noquote, &globalclusid))" '*/';
19769 +        put "/*-------------------------------------------------*/";
19770 +        put ' ';
19771 +        %let dsid = %sysfunc(open(work._tmpindata));
19772 +
19773 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
19774 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
19775 +        %let k = 1;
19776 +        %do %while(^%sysfunc(fetch(&dsid)));
19777 +               %let _name = %sysfunc(getvarc(&dsid, &vn_name));
19778 +               %if &k > 2 %then %do;
19779 +                %let cn = %eval(&k-2);
19780 +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_gcluscompnum, noquote, &globalclusid, &cn))" "------ */";
19781 +                %end;
19782 +                %let k = %eval(&k+1);
19783 +
19784 +        %end;
19785 +        %let rc = %sysfunc(rewind(&dsid));
19786 +
19787 +        %do j= 2 %to &nvar;
19788 +            %let _varname = %sysfunc(varname(&dsid, &j));
19789 +            %do %while(^%sysfunc(fetch(&dsid)));
19790 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
19791 +                %if &_name = MEAN %then
19792 +                %let _mean = %sysfunc(getvarn(&dsid, &j));
19793 +                %else %if &_name = STD %then
19794 +                %let _std = %sysfunc(getvarn(&dsid, &j));
19795 +                %else %do;
19796 +                      %let coeff =  %sysfunc(getvarn(&dsid, &j));
19797 +                      %let abscoeff = %sysfunc(abs(&coeff));
19798 +                          %if &abscoeff >  0 %then %do;
19799 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
19800 +                           %end;
19801 +                 %end;
19802 +             %end;
19803 +             %let rc = %sysfunc(rewind(&dsid));
19804 +         %end;
19805 +
19806 +        %let dsid= %sysfunc(close(&dsid));
19807 +
19808 +     run;
19809 +
19810 +     filename _file_;
19811 +     proc datasets lib = work nolist;
19812 +           delete _tmpindata;
19813 +     run;
19814 +     quit;
19815 +%mend CreateScoreCode2;
19816 +
19817 +
19818 +%macro MakeDeltaCode2(groupds=,deltacodefile=);
19819 +
19820 +     /*--- Build Code to Modify Metadata ---*/
19821 +     filename X "&deltacodefile";
19822 +     data _null_;
19823 +        FILE X;
19824 +        set &groupds end=eof;
19825 +        if _N_=1 then do;
19826 +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
19827 +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
19828 +           %end;
19829 +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
19830 +           put "if upcase(strip(NAME)) in (";
19831 +        end;
19832 +        if Strip(upcase(Selected)) eq 'YES' then do;
19833 +           string = '"'!!trim(left(VARIABLE))!!'"';
19834 +           put string;
19835 +        end;
19836 +        if eof then do;
19837 +           put ') then ROLE="INPUT";';
19838 +           put 'else ROLE="REJECTED";';
19839 +           put 'end;';
19840 +
19841 +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
19842 +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
19843 +           %end;
19844 +        end;
19845 +     run;
19846 +     quit;
19847 +
19848 +     filename X;
19849 +     quit;
19850 +%mend MakeDeltaCode2;
19851 +
19852 +%macro getInitialGClusterNumber(indata=, ninput=, ndummy=0, div=100, ngc=);
19853 +  %global &ngc;
19854 +  data _null_;
19855 +  %if &indata ne %then %do;
19856 +      %let dsid = %sysfunc(open(&indata));
19857 +           %let nvar = %sysfunc(attrn(&dsid, NVAR));
19858 +      %let dsid = %sysfunc(close(&dsid));
19859 +  %end;
19860 +  %else %do;
19861 +       %let nvar = %eval(&ninput+&ndummy); ;
19862 +  %end;
19863 +  %let numgc = %eval(&nvar/&div+2);
19864 +  %let &ngc = &numgc;
19865 +   run;
19866 +  quit;
19867 +%mend getInitialGClusterNumber;
19868 +
19869 +
19870 +%macro MakeGobalConstellData(indata=, outlink=, outnode=);
19871 +data &outlink(drop = Selected);
19872 +     set &indata;
19873 +     LINKID = _N_;
19874 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid, noquote))" ;
19875 +run;
19876 +data &outnode(keep=NODEID TYPE LABEL);
19877 +    set &indata;
19878 +    length TYPE $16;
19879 +    rename VARIABLE = NODEID;
19880 +    *label  CLUSNAME="Node ID";
19881 +    label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
19882 +    TYPE = "VARIABLE";
19883 +    *label TYPE = "Node Type";
19884 +    label TYPE =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
19885 +    run;
19886 +data _tmp(keep=NODEID TYPE LABEL);
19887 +    set &indata;
19888 +    length TYPE $16;
19889 +    rename CLUSNAME = NODEID;
19890 +    label  CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
19891 +    TYPE = "GCLUSTER";
19892 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
19893 +    run;
19894 +proc sort data=_tmp;
19895 +    by NODEID;
19896 +run;
19897 +data _tmp;
19898 +    set _tmp; by NODEID;
19899 +    if first.NODEID then output;
19900 +run;
19901 +proc sort data=&outnode;
19902 +    by NODEID;
19903 +run;
19904 +data  &outnode;
19905 +    set _tmp &outnode;
19906 +run;
19907 +proc datasets lib = work nolist;
19908 +     delete _tmp;
19909 +run;
19910 +quit;
19911 +%mend MakeGobalConstellData;
19912 +
19913 +/* Make contellation plot data among GCLUSTERS */
19914 +
19915 +%Macro MakeGClusterConstData(indata=, inoutrsq=, outnode=, outlink=);
19916 +
19917 +data &outlink(keep = _NAME_ _PARENT_ _LABEL_ LINKID);
19918 +     set &indata;
19919 +     LINKID = _N_;
19920 +     if upcase(substr(strip(_NAME_),1, 2))="CL" then do;
19921 +        _NAME_ = "ROOT"||upcase(substr(strip(_NAME_),5));
19922 +     end;
19923 +     if _PARENT_ ne " " and upcase(substr(strip(_PARENT_),1, 2))="CL" then do;
19924 +        _PARENT_ = "ROOT"||upcase(substr(strip(_PARENT_),5));
19925 +     end;
19926 +     if upcase(substr(strip(_LABEL_),1, 2))="CL" then do;
19927 +        _LABEL_ = "ROOT"||upcase(substr(strip(_LABEL_),5));
19928 +    end;
19929 +run;
19930 +
19931 +data _tmp_outrsquare;
19932 +        set &inoutrsq;
19933 +        if upcase(strip(TYPE)) = 'CLUSTERCOMP' then delete;
19934 +run;
19935 +
19936 +proc freq data =_tmp_outrsquare noprint;
19937 +         tables GCluster/out=_tmp_GCLUSFREQ(rename=(GCLUSTER=_NAME_));
19938 +run;
19939 +
19940 +data &outnode(keep=_NAME_ TYPE LABEL);
19941 +    set &outlink;
19942 +    length TYPE $16;
19943 +    length LABEL $100;
19944 +    /*label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;*/
19945 +
19946 +    if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
19947 +    TYPE = "GCLUSTER";
19948 +    LABEL = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
19949 +    end;
19950 +    else do;
19951 +    TYPE= "ROOT";
19952 +    LABEL= _NAME_;
19953 +    end;
19954 +    label TYPE  =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
19955 +    label LABEL =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
19956 +    label _NAME_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
19957 +    run;
19958 +
19959 +proc sort data=&outnode;
19960 +     by _NAME_;
19961 +proc sort data=_tmp_GCLUSFREQ;
19962 +     by _NAME_;
19963 +run;
19964 +
19965 +data  &outnode;
19966 +     merge &outnode _tmp_GCLUSFREQ; by _NAME_;
19967 +     if COUNT=. then COUNT=1;
19968 +run;
19969 +
19970 +proc datasets lib = work nolist;
19971 +     delete _tmp_outrsquare _tmp_GCLUSFREQ;
19972 +run;
19973 +
19974 +quit;
19975 +%Mend MakeGClusterConstData;
19976 +
19977 +
19978 +%macro CreateGClusterScoreCode(indata=,  globalclusid=, fileref=);
19979 +
19980 +    data _gscoretmpds;
19981 +          set &indata;
19982 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = 1 ) or (_TYPE_ in ('MEAN' 'STD'));
19983 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
19984 +          if _TYPE_ = 'STD' then _NAME_='STD';
19985 +          if _TYPE_ = 'SCORE' then _NAME_ = "GC"||strip(&globalclusid);
19986 +          DROP _TYPE_ _NCL_;
19987 +     run;
19988 +
19989 +    /*  %let gscorefile =  %bquote(&EM_NODEDIR)&EM_DSEP.gclusterscore.sas;
19990 +        GCluster Component &globalclusid ------ */
19991 +
19992 +    filename _file_  "&fileref";
19993 +
19994 +    data _null_;
19995 +        %if &globalclusid eq 1 %then %do;
19996 +          FILE _file_;
19997 +        %end;
19998 +        %else %do;
19999 +          FILE _file_ MOD;
20000 +        %end;
20001 +
20002 +        %let dsid = %sysfunc(open(work._gscoretmpds));
20003 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
20004 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
20005 +
20006 +        %let k = 1;
20007 +        %do %while(^%sysfunc(fetch(&dsid)));
20008 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
20009 +                %if &k > 2 %then %do;
20010 +                put "&_name = 0 ; ";
20011 +                %end;
20012 +                %let k = %eval(&k+1);
20013 +        %end;
20014 +
20015 +        %let rc = %sysfunc(rewind(&dsid));
20016 +        %do i= 2 %to &nvar;
20017 +            %let _varname =  %sysfunc(varname(&dsid, &i));
20018 +            %do %while(^%sysfunc(fetch(&dsid)));
20019 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
20020 +                %if &_name = MEAN %then
20021 +                %let _mean = %sysfunc(getvarn(&dsid, &i));
20022 +                %else %if &_name = STD %then
20023 +                %let _std = %sysfunc(getvarn(&dsid, &i));
20024 +                %else %do;
20025 +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
20026 +                      %let abscoeff = %sysfunc(abs(&coeff));
20027 +                          %if &abscoeff >  0 %then %do;
20028 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
20029 +                           %end;
20030 +                 %end;
20031 +             %end;
20032 +             %let rc = %sysfunc(rewind(&dsid));
20033 +
20034 +         %end;
20035 +
20036 +        %let dsid= %sysfunc(close(&dsid));
20037 +       run;
20038 +
20039 +
20040 +       proc datasets lib=work nolist;
20041 +            delete _gscoretmpds;
20042 +       run;
20043 +      quit;
20044 +
20045 +%mend CreateGClusterScoreCode;
20046 +
20047 +
20048 +%macro MakeGClusterCorrelation(Indata=, ngcluster=, gscorecode=, outrsquare=);
20049 +
20050 +   %EM_REGISTER(KEY=GSCORE, TYPE=DATA);
20051 +   %EM_GETNAME(KEY=GSCORE, TYPE=DATA);
20052 +   %EM_REGISTER(KEY=GSCORESTAT, TYPE=DATA);
20053 +   %EM_GETNAME(KEY=GSCORESTAT, TYPE=DATA);
20054 +   %EM_REGISTER(KEY=GSCORETREE, TYPE=DATA);
20055 +   %EM_GETNAME(KEY=GSCORETREE, TYPE=DATA);
20056 +   %EM_REGISTER(KEY=GSCORECORR, TYPE=DATA);
20057 +   %EM_GETNAME(KEY=GSCORECORR, TYPE=DATA);
20058 +   %EM_REGISTER(KEY=GSCORECORRPLOT, TYPE=DATA);
20059 +   %EM_GETNAME(KEY=GSCORECORRPLOT, TYPE=DATA);
20060 +   %EM_REGISTER(KEY=GCLUSLINK, TYPE=DATA);
20061 +   %EM_GETNAME(KEY=GCLUSLINK, TYPE=DATA);
20062 +   %EM_REGISTER(KEY=GCLUSNODE, TYPE=DATA);
20063 +   %EM_GETNAME(KEY=GCLUSNODE, TYPE=DATA);
20064 +
20065 +   filename gsfile "&gscorecode";
20066 +
20067 +   data &EM_USER_GSCORE;
20068 +             set &indata;
20069 +             %include  gsfile;
20070 +        keep
20071 +        %do i=1 %to &ngcluster;
20072 +         %let gcvarname = GC&i;
20073 +         &gcvarname
20074 +        %end;
20075 +     ;
20076 +   run;
20077 +
20078 +   proc varclus data=&EM_USER_GSCORE outstat=&EM_USER_GSCORESTAT outtree=&EM_USER_GSCORETREE
20079 +    %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
20080 +    %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
20081 +    %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
20082 +    noprint  ;
20083 +     var
20084 +       %do i=1 %to &ngcluster;
20085 +         %let gcvarname = GC&i;
20086 +         &gcvarname
20087 +        %end;
20088 +   ;
20089 +   run;
20090 +
20091 +
20092 +   %MakeVarClusCorrData(statds=&EM_USER_GSCORESTAT, corrds=&EM_USER_GSCORECORR, corrplotds=&EM_USER_GSCORECORRPLOT );
20093 +   data &EM_USER_GSCORECORRPLOT ;
20094 +        set &EM_USER_GSCORECORRPLOT;
20095 +        rename _X_ = X;
20096 +        rename _Y_ = Y;
20097 +        label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
20098 +        label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
20099 +   run;
20100 +
20101 +   %MakeGClusterConstData(indata=&EM_USER_GSCORETREE, inoutrsq=&outrsquare, outnode=&EM_USER_GCLUSNODE, outlink=&EM_USER_GCLUSLINK);
20102 +
20103 +   data &EM_USER_GSCORETREE;
20104 +        length _NAME_ $32;
20105 +        length _LABEL_ $100;
20106 +        set &EM_USER_GSCORETREE(DROP=_LABEL_);
20107 +        if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
20108 +         _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
20109 +        end;else do;
20110 +         _LABEL_ = _NAME_;
20111 +        end;
20112 +       label _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
20113 +
20114 +   run;
20115 +
20116 +   quit;
20117 +
20118 +%mend MakeGClusterCorrelation;
20119 +
20120 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_SCORE.SOURCE.
20121 +%macro score;
20122 +
20123 +filename temp catalog 'sashelp.emexpl.variableclustering_score_macros.source';
20124 +%include temp;
20125 +filename temp;
20126 +
20127 +%EM_GETNAME(key=VARCLUSMETA, type=DATA) ;
20128 +
20129 +data _null_;
20130 +         set &EM_USER_VARCLUSMETA;
20131 +         if _N_=1 then
20132 +         call symput('_trainnum', TrainNum);
20133 +         call symput('_exportedcomp', ExportedComp);
20134 +         call symput('_hidevariable', HideVariable);
20135 +         call symput('_newTrain', NewTrain);
20136 +run;
20137 +
20138 +%if &_newTrain = N %then %do;
20139 +        %if &EM_PROPERTY_EXPORTEDCOMP eq &_exportedcomp %then %let _exportedCompChanged = N;
20140 +        %else %let _exportedCompChanged = Y;
20141 +        %if &EM_PROPERTY_HIDEVARIABLE eq &_hidevariable %then %let _hideVariableChanged = N;
20142 +        %else  %let _hideVariableChanged = Y;
20143 +%end;
20144 +%else %do;
20145 +        %let _exportedCompChanged = Y;
20146 +        %let _hideVariableChanged = Y;
20147 +%end;
20148 +
20149 +%if (&_trainnum = 1 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = NO %then %do;
20150 +     filename temp catalog 'sashelp.emexpl.variableclustering_score1.source';
20151 +     %include temp;
20152 +     filename temp;
20153 +     %score1(ExportedCompChanged=&_exportedCompChanged, HideVariableChanged=&_hideVariableChanged);
20154 +%end;
20155 +%if (&_trainnum = 2 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = YES %then %do;
20156 +     filename temp catalog 'sashelp.emexpl.variableclustering_score2.source';
20157 +     %include temp;
20158 +     filename temp;
20159 +     %score2(ExportedCompChanged=&_exportedCompChanged, HideVariableChanged=&_hideVariableChanged);
20160 +%end;
20161 +
20162 +  /* store  current property values */
20163 + data &EM_USER_VARCLUSMETA;
20164 +       set &EM_USER_VARCLUSMETA;
20165 +        ExportedComp = "&EM_PROPERTY_EXPORTEDCOMP";
20166 +        HideVariable = "&EM_PROPERTY_HIDEVARIABLE";
20167 + run;
20168 +
20169 +%mend score;
20170 +
20171 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_SCORE_MACROS.SOURCE.
20172 +
20173 +%macro ChangeVariableSelectionFlag(Indata=, gcluster=);
20174 +     proc sort data =&indata;
20175 +              by Cluster RsqRatio Type;
20176 +     run;
20177 +     /*----------------------------------------------------------------------
20178 +      The Type variabe is used becuse the variable need to be selected
20179 +        instead of Cluster component when only one variable is in the cluster
20180 +     +-----------------------------------------------------------------------*/
20181 +
20182 +     %if &EM_PROPERTY_EXPORTEDCOMP eq CLUSTERCOMP %then %do;
20183 +         data &indata;
20184 +              set &indata; by cluster;
20185 +              if first.Cluster then Selected = 'YES';
20186 +              else Selected = 'NO';
20187 +         run;
20188 +         quit;
20189 +    %end;
20190 +    %else %do;
20191 +         data &indata(drop = _var _varchange);
20192 +              set &indata; retain _var 0; by Cluster;
20193 +             if first.Cluster then  _varchange = 0;
20194 +                 else _varchange =1;
20195 +             if _var ne _varchange then  Selected  = 'YES';
20196 +             else Selected = 'NO';
20197 +             if last.cluster then  _var = 0;
20198 +             else _var = _varchange;
20199 +         run;
20200 +         quit;
20201 +    %end;
20202 +%mend ChangeVariableSelectionFlag;
20203 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      3:15
NOTE: There were 1 observations read from the data set EMWS2.VARCLUS_VARCLUSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_SCORE1.SOURCE.
20204 +
20205 +%macro score1(ExportedCompChanged=,
20206 +              HideVariableChanged=);
20207 +
20208 +   %EM_GETNAME(KEY=OUTRSQUARE, TYPE=DATA);
20209 +   %if &ExportedCompChanged = Y %then %do;
20210 +   %ChangeVariableSelectionFlag(Indata=&EM_USER_OUTRSQUARE);
20211 +   %end;
20212 +   %MakeDeltaCode(groupds=&EM_USER_OUTRSQUARE, DeltaCodeFile=&EM_FILE_CDELTA_TRAIN);
20213 +
20214 +%mend score1;
20215 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTRSQUARE has 117 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTRSQUARE has 117 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The file X is:
      Filename=C:\Users\Kyle McLester\Desktop\dsba-6201\final-project\Workspaces\EMWS2\VarClus\CDELTA_TRAIN.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=13Apr2022:13:20:59,
      Create Time=13Apr2022:13:20:34
 
NOTE: 37 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 75.
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: Fileref X has been deassigned.
 
NOTE: There were 1 observations read from the data set EMWS2.VARCLUS_VARCLUSMETA.
NOTE: The data set EMWS2.VARCLUS_VARCLUSMETA has 1 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
20216  *------------------------------------------------------------*;
20217  * End SCORE: VarClus;
20218  *------------------------------------------------------------*;
20219
 
20220  filename emflow "C:\Users\Kyle McLester\Desktop\dsba-6201\final-project\Workspaces\EMWS2\VarClus\EMFLOWSCORE.sas";
20221  *------------------------------------------------------------*;
20222  * VarClus: Scoring DATA data;
20223  *------------------------------------------------------------*;
20224  data EMWS2.VarClus_TRAIN
20225  / view=EMWS2.VarClus_TRAIN
20226  ;
20227  set EMWS2.Ids_DATA
20228  ;
20229  %inc emflow;
NOTE: %INCLUDE (level 1) file EMFLOW is file C:\Users\Kyle McLester\Desktop\dsba-6201\final-project\Workspaces\EMWS2\VarClus\EMFLOWSCORE.sas.
20230 +
20231 +/*-------------------------------------------------*/
20232 +/* Varclus Score Code Begins*/
20233 +/*-------------------------------------------------*/
20234 +
20235 +Clus1 = 0 ; /*---Cluster Component 1------ */
20236 +Clus2 = 0 ; /*---Cluster Component 2------ */
20237 +Clus3 = 0 ; /*---Cluster Component 3------ */
20238 +Clus4 = 0 ; /*---Cluster Component 4------ */
20239 +Clus5 = 0 ; /*---Cluster Component 5------ */
20240 +Clus6 = 0 ; /*---Cluster Component 6------ */
20241 +Clus7 = 0 ; /*---Cluster Component 7------ */
20242 +Clus8 = 0 ; /*---Cluster Component 8------ */
20243 +Clus9 = 0 ; /*---Cluster Component 9------ */
20244 +Clus10 = 0 ; /*---Cluster Component 10------ */
20245 +Clus11 = 0 ; /*---Cluster Component 11------ */
20246 +Clus12 = 0 ; /*---Cluster Component 12------ */
20247 +Clus13 = 0 ; /*---Cluster Component 13------ */
20248 +Clus14 = 0 ; /*---Cluster Component 14------ */
20249 +Clus15 = 0 ; /*---Cluster Component 15------ */
20250 +Clus16 = 0 ; /*---Cluster Component 16------ */
20251 +Clus17 = 0 ; /*---Cluster Component 17------ */
20252 +Clus18 = 0 ; /*---Cluster Component 18------ */
20253 +Clus19 = 0 ; /*---Cluster Component 19------ */
20254 +Clus20 = 0 ; /*---Cluster Component 20------ */
20255 +Clus21 = 0 ; /*---Cluster Component 21------ */
20256 +Clus22 = 0 ; /*---Cluster Component 22------ */
20257 +Clus23 = 0 ; /*---Cluster Component 23------ */
20258 +Clus24 = 0 ; /*---Cluster Component 24------ */
20259 +Clus25 = 0 ; /*---Cluster Component 25------ */
20260 +Clus26 = 0 ; /*---Cluster Component 26------ */
20261 +Clus27 = 0 ; /*---Cluster Component 27------ */
20262 +Clus28 = 0 ; /*---Cluster Component 28------ */
20263 +Clus29 = 0 ; /*---Cluster Component 29------ */
20264 +Clus30 = 0 ; /*---Cluster Component 30------ */
20265 +Clus31 = 0 ; /*---Cluster Component 31------ */
20266 +Clus4 = Clus4+0.31506511949962 * (ACTBUY - 0.98415915294896)/1.16124174434748;
20267 +Clus5 = Clus5+0.32810012810844 * (BUYPROP - 0.18857953524929)/0.25695638275664;
20268 +Clus1 = Clus1+0.14330330310549 * (CATALOGCNT - 3.76582016709405)/3.13325249110829;
20269 +Clus2 = Clus2+0.50000309368265 * (DAYLAST - 1179.72210273802)/1228.08606059116;
20270 +Clus26 = Clus26+0.32628336535546 * (DEPT01 - 0.4947886508396)/1.79329791664614;
20271 +Clus26 = Clus26+0.30955815400123 * (DEPT02 - 0.29224915212176)/1.1516033877047;
20272 +Clus26 = Clus26+0.35512120308918 * (DEPT03 - 1.08571842170568)/2.82789221870654;
20273 +Clus26 = Clus26+0.32083367414143 * (DEPT04 - 0.6884357680536)/2.32660485062198;
20274 +Clus26 = Clus26+0.29297494554874 * (DEPT05 - 0.5405947555629)/1.51743946540617;
20275 +Clus1 = Clus1+0.0887297183822 * (DEPT06 - 0.84913971378939)/1.95857457263519;
20276 +Clus27 = Clus27+0.20512615497254 * (DEPT07 - 0.02566382661924)/0.3131274985394;
20277 +Clus27 = Clus27+0.33802255775708 * (DEPT08 - 0.31989825461163)/1.3169786309156;
20278 +Clus27 = Clus27+0.35222262608128 * (DEPT09 - 0.25169575647282)/1.22487244242676;
20279 +Clus27 = Clus27+0.35143694277486 * (DEPT10 - 0.39688973446935)/1.75418840679095;
20280 +Clus27 = Clus27+0.28411319244927 * (DEPT11 - 0.15166680453304)/0.75579552616881;
20281 +Clus27 = Clus27+0.38625548800345 * (DEPT12 - 0.21403755480188)/0.89821928073595;
20282 +Clus1 = Clus1+0.10634376480481 * (DEPT13 - 1.3046157663992)/2.56939267433771;
20283 +Clus1 = Clus1+0.09693720610605 * (DEPT14 - 0.83596658118951)/2.17212431012905;
20284 +Clus31 = Clus31+0.57708798311258 * (DEPT15 - 0.28281909173628)/1.20403421852017;
20285 +Clus31 = Clus31+0.58306281612114 * (DEPT16 - 0.22692116800397)/1.02932891897637;
20286 +Clus1 = Clus1+0.06081830779099 * (DEPT17 - 0.19412275622466)/0.95098324822245;
20287 +Clus1 = Clus1+0.04387664121344 * (DEPT18 - 0.13243444453635)/0.70056021155445;
20288 +Clus31 = Clus31+0.36627810877786 * (DEPT19 - 0.07529572338489)/0.59843051665372;
20289 +Clus29 = Clus29+0.69557742711936 * (DEPT20 - 0.03027545702704)/0.31175490782046;
20290 +Clus29 = Clus29+0.69557742711937 * (DEPT21 - 0.01873604102903)/0.24920616999885;
20291 +Clus1 = Clus1+0.11736814154308 * (DEPT22 - 2.12523781950533)/3.59746794467555;
20292 +Clus28 = Clus28+0.60553088849056 * (DEPT23 - 2.13704607494416)/3.81699771108747;
20293 +Clus28 = Clus28+0.60553088849056 * (DEPT24 - 0.63280668376209)/1.719595262964;
20294 +Clus4 = Clus4+0.26044008006812 * (DEPT25 - 1.76422781040615)/4.78913429389962;
20295 +Clus5 = Clus5+0.1757644566842 * (DEPT26 - 0.18853916783853)/0.89185805086544;
20296 +Clus1 = Clus1+0.07901458625394 * (DEPT27 - 0.58617338075936)/1.54885901028385;
20297 +Clus3 = Clus3+0.40859410576534 * (DOLINDEA - 47.7494687323893)/37.7517737016191;
20298 +Clus1 = Clus1+0.15306109019156 * (DOLINDET - 196.670314128546)/314.090974040841;
20299 +Clus21 = Clus21+0.33876946461469 * (DOLL24 - 45.6909612044007)/94.2604550235214;
20300 +Clus20 = Clus20+0.53490724350313 * (DOLLARQ01 - 3.62876933575979)/19.700562502979;
20301 +Clus23 = Clus23+0.53593553090625 * (DOLLARQ02 - 3.70868103234345)/20.5983872748928;
20302 +Clus9 = Clus9+0.53237731533242 * (DOLLARQ03 - 2.81364484241872)/16.6445011800459;
20303 +Clus14 = Clus14+0.53374054179686 * (DOLLARQ04 - 4.68547894780378)/22.20171056531;
20304 +Clus13 = Clus13+0.53344859897161 * (DOLLARQ05 - 4.34862333526346)/21.3635459374931;
20305 +Clus15 = Clus15+0.53461810821576 * (DOLLARQ06 - 3.78087641657705)/19.6196875771167;
20306 +Clus12 = Clus12+0.53699975004809 * (DOLLARQ07 - 4.19731987757465)/22.140420032962;
20307 +Clus24 = Clus24+0.54428267721203 * (DOLLARQ08 - 6.16534825047564)/27.5977086736842;
20308 +Clus19 = Clus19+0.53477634393244 * (DOLLARQ09 - 4.23611733807593)/20.6042865818524;
20309 +Clus7 = Clus7+0.53381163404365 * (DOLLARQ10 - 3.64996277607742)/19.4042840623867;
20310 +Clus10 = Clus10+0.53489767784727 * (DOLLARQ11 - 4.00276325585242)/20.3574023706514;
20311 +Clus4 = Clus4+0.37047891694579 * (DOLLARQ12 - 6.4048078831996)/27.4867988980488;
20312 +Clus22 = Clus22+0.53996828628643 * (DOLLARQ13 - 5.42704834973943)/25.9122296804207;
20313 +Clus17 = Clus17+0.5399332942984 * (DOLLARQ14 - 4.42012821573331)/22.822227521149;
20314 +Clus6 = Clus6+0.53540238383935 * (DOLLARQ15 - 4.91827942757879)/23.7277145218743;
20315 +Clus16 = Clus16+0.53700037840571 * (DOLLARQ16 - 7.6728978823724)/30.1040113753565;
20316 +Clus21 = Clus21+0.4441728554986 * (DOLLARQ17 - 5.58622218545785)/25.6532009501365;
20317 +Clus8 = Clus8+0.53503713605332 * (DOLLARQ18 - 4.97158760029779)/23.4434084567651;
20318 +Clus11 = Clus11+0.53527758723698 * (DOLLARQ19 - 4.45103585904541)/22.4969470207664;
20319 +Clus5 = Clus5+0.37912776829946 * (DOLLARQ20 - 8.69922036562164)/32.1668230669876;
20320 +Clus18 = Clus18+0.5382879613387 * (DOLLARQ21 - 4.74309599636034)/23.9462495307888;
20321 +Clus25 = Clus25+0.53772787445298 * (DOLLARQ22 - 4.91402866242038)/24.5188036933349;
20322 +Clus3 = Clus3+0.40740398696753 * (DOLNETDA - 45.3010961889238)/36.4093965330672;
20323 +Clus1 = Clus1+0.15236476002572 * (DOLNETDT - 187.859166804533)/302.353627018907;
20324 +Clus1 = Clus1+0.14153333224352 * (FREQPRCH - 4.16699065265944)/5.29065554512795;
20325 +Clus2 = Clus2+0.50000309368265 * (MONLAST - 38.6783439490445)/40.3446077417396;
20326 +Clus30 = Clus30+1 * (TENURE - 83.2569898254611)/60.1049434473642;
20327 +Clus20 = Clus20+0.53490724350313 * (TOTORDQ01 - 0.07777731822317)/0.31389690802721;
20328 +Clus23 = Clus23+0.53593553090625 * (TOTORDQ02 - 0.07343452725618)/0.30234440503469;
20329 +Clus9 = Clus9+0.53237731533242 * (TOTORDQ03 - 0.05879311771031)/0.26004188102152;
20330 +Clus14 = Clus14+0.53374054179686 * (TOTORDQ04 - 0.09049549176937)/0.3379915291354;
20331 +Clus13 = Clus13+0.53344859897161 * (TOTORDQ05 - 0.08840681611382)/0.32682632295319;
20332 +Clus15 = Clus15+0.53461810821576 * (TOTORDQ06 - 0.07914219538423)/0.30607953609609;
20333 +Clus12 = Clus12+0.53699975004809 * (TOTORDQ07 - 0.08507734303912)/0.31943207185789;
20334 +Clus24 = Clus24+0.54428267721203 * (TOTORDQ08 - 0.1171933162379)/0.43081744427325;
20335 +Clus19 = Clus19+0.53477634393244 * (TOTORDQ09 - 0.09004053271569)/0.32393134663276;
20336 +Clus7 = Clus7+0.53381163404365 * (TOTORDQ10 - 0.07388948630986)/0.29594134802121;
20337 +Clus10 = Clus10+0.53489767784727 * (TOTORDQ11 - 0.08365042600711)/0.31311042011335;
20338 +Clus4 = Clus4+0.38895539317086 * (TOTORDQ12 - 0.12589957812887)/0.40321126873265;
20339 +Clus22 = Clus22+0.5420216551507 * (TOTORDQ13 - 0.10960377202415)/0.35561583257189;
20340 +Clus17 = Clus17+0.5399332942984 * (TOTORDQ14 - 0.08939945404913)/0.32093487933982;
20341 +Clus6 = Clus6+0.53540238383935 * (TOTORDQ15 - 0.09862271486475)/0.34825794428353;
20342 +Clus16 = Clus16+0.53700037840571 * (TOTORDQ16 - 0.14653817520059)/0.42958597633604;
20343 +Clus21 = Clus21+0.42434875219505 * (TOTORDQ17 - 0.11036893043262)/0.36146626964949;
20344 +Clus8 = Clus8+0.53503713605332 * (TOTORDQ18 - 0.09496236247828)/0.3326239150071;
20345 +Clus11 = Clus11+0.53527758723698 * (TOTORDQ19 - 0.08313342708247)/0.30721525746109;
20346 +Clus5 = Clus5+0.40173164867581 * (TOTORDQ20 - 0.1598147075854)/0.46087659616133;
20347 +Clus18 = Clus18+0.5382879613387 * (TOTORDQ21 - 0.09179832905947)/0.32778817509559;
20348 +Clus25 = Clus25+0.53772787445298 * (TOTORDQ22 - 0.08805525684506)/0.31503400070093;
20349 +Clus1 = Clus1+0.15174075234892 * (UNITSIDD - 10.9243527173463)/17.1548539548545;
20350 +Clus22 = Clus22+-0.05262146714796 * (UNITSLAP - 22.0499810323411)/20.4346713850633;
20351 +Clus3 = Clus3+0.30867278403585 * (UNTLANPO - 2.66878279488799)/2.31718254874154;
NOTE: %INCLUDE (level 1) ending.
20352  run;
 
NOTE: DATA STEP view saved on file EMWS2.VARCLUS_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: View EMWS2.IDS_DATA.VIEW used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
 
NOTE: DATA statement used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
 
 
20353  quit;
20354  filename emflow;
NOTE: Fileref EMFLOW has been deassigned.
 
20356  *------------------------------------------------------------*;
20357  * VarClus: Computing metadata for TRAIN data;
20358  *------------------------------------------------------------*;
 
NOTE: View EMWS2.VARCLUS_TRAIN.VIEW used (Total process time):
      real time           0.45 seconds
      cpu time            0.34 seconds
 
NOTE: View EMWS2.VARCLUS_TRAIN.VIEW used (Total process time):
      real time           0.17 seconds
      cpu time            0.17 seconds
 
*------------------------------------------------------------*
* Report Log
Date:                April 13, 2022
Time:                13:21:01
*------------------------------------------------------------*
20756  %let EMEXCEPTIONSTRING=;
20757  *------------------------------------------------------------*;
20758  * REPORT: VarClus;
20759  *------------------------------------------------------------*;
20760  %let EM_ACTION = REPORT;
20761  %let syscc = 0;
20762
20763  %macro main;
20764
20765     filename temp catalog 'sashelp.emexpl.variableclustering_macros.source';
20766     %include temp;
20767     filename temp catalog 'sashelp.emexpl.variableclustering_macros2.source';
20768     %include temp;
20769     filename temp;
20770
20771    %SetProperties;
20772
20773     %if %upcase(&EM_ACTION) = CREATE %then %do;
20774         filename temp catalog 'sashelp.emexpl.variableclustering_create.source';
20775         %include temp;
20776         filename temp;
20777         %create;
20778     %end;
20779     %else
20780     %if %upcase(&EM_ACTION) = TRAIN %then %do;
20781          filename temp catalog 'sashelp.emexpl.variableclustering_train.source';
20782             %include temp;
20783             filename temp;
20784             %train;
20785     %end;
20786     %else
20787     %if %upcase(&EM_ACTION) = SCORE %then %do;
20788             filename temp catalog 'sashelp.emexpl.variableclustering_score.source';
20789             %include temp;
20790             filename temp;
20791             %score;
20792     %end;
20793     %else
20794     %if %upcase(&EM_ACTION) = REPORT %then %do;
20795             filename temp catalog 'sashelp.emexpl.variableclustering_report.source';
20796             %include temp;
20797             filename temp;
20798             %report;
20799     %end;
20800     /*
20801     %if %upcase(&EM_ACTION) = OPENTESTTABLE %then %do;
20802         %put 'OPENING TABLE';
20803     %end;
20804     %if %upcase(&EM_ACTION) = CLOSETESTTABLE %then %do;
20805         %put 'CLOSE TABLE';
20806     %end;
20807     */
20808  %mend main;
20809  %main;
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS.SOURCE.
20810 +
20811 +/* Initialize property macro variables */
20812 +%macro SetProperties;
20813 +   %em_checkmacro(name=EM_PROPERTY_MAXCLUS,       global=Y, value=DEFAULT);
20814 +   %em_checkmacro(name=EM_PROPERTY_HIDEVARIABLE,  global=Y, value=Y);
20815 +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,   global=Y, value=SHORT);
20816 +   %em_checkmacro(name=EM_PROPERTY_CLUSSOURCE,    global=Y, value=CORR);
20817 +   %em_checkmacro(name=EM_PROPERTY_CLUSCOMP,      global=Y, value=PRINCIPAL);
20818 +   %em_checkmacro(name=EM_PROPERTY_CLUSHIERACHY,      global=Y, value=Y);
20819 +   %em_checkmacro(name=EM_PROPERTY_INCLUDECLASSVAR,      global=Y, value=N);
20820 +   %em_checkmacro(name=EM_PROPERTY_EXPORTEDCOMP,      global=Y, value=CLUSTERCOMP);
20821 +   %em_checkmacro(name=EM_PROPERTY_MAXEIGEN,         global=Y, value=DEFAULT);
20822 +   %em_checkmacro(name=EM_PROPERTY_PROPORTION,      global=Y, value=DEFAULT);
20823 +   %em_checkmacro(name=EM_PROPERTY_PRINTOPTION,      global=Y, value=SHORT);
20824 +   %em_checkmacro(name=EM_PROPERTY_TWOSTAGECLUS,      global=Y, value=AUTO);
20825 +   %em_checkmacro(name=EM_PROPERTY_SUPPRESSSAMPWARN,      global=Y, value=N);
20826 +
20827 +%mend SetProperties;
20828 +
20829 +%Macro MakeDummyVariables(indata=,
20830 +                          outvar=,
20831 +                          outdata=,
20832 +                          fileref=,
20833 +                          recreatecmeta=N, /* optional */
20834 +                          incmeta=,     /* optional */
20835 +                          outcmeta=,    /* optional */
20836 +                          ndummyvars=_ndummyvars
20837 +                          );
20838 +    %global &ndummyvars;
20839 +
20840 +    proc dmdb batch data=&indata out=_dmdbdat dmdbcat=_dmdbcat classout=_classout;;
20841 +       class
20842 +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
20843 +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
20844 +    ;
20845 +    run;
20846 +    %let &ndummyvars = 0;
20847 +    data _null_;
20848 +    %let dsid = %sysfunc(open(work._classout));
20849 +      %let &ndummyvars = %sysfunc(attrn(&dsid, NOBS));
20850 +    %let dsid = %sysfunc(close(&dsid));
20851 +    run;
20852 +
20853 +    proc dmzip data=_dmdbdat dmdbcat=_dmdbcat;
20854 +       input
20855 +       %EM_BINARY_INPUT %EM_NOMINAL_INPUT %EM_ORDINAL_INPUT
20856 +       %EM_BINARY_REJECTED %EM_NOMINAL_REJECTED %EM_ORDINAL_REJECTED
20857 +        / level=nominal stdize=no;
20858 +       make outvar = &outvar;
20859 +       score data = &indata out =&outdata;
20860 +       code  file=  "&fileref";
20861 +    run;
20862 +    %if &recreatecmeta eq Y %then %do;
20863 +    proc contents data =&outvar out=_tmpds(keep=NAME LABEL);
20864 +    data _tmpds;
20865 +        set _tmpds;
20866 +           ROLE = 'INPUT';
20867 +           LEVEL = 'INTERVAL';
20868 +           CREATOR='DMZIP';
20869 +           if NAME = '_TYPE_' then delete;
20870 +    run;
20871 +    data &outcmeta;
20872 +         set &incmeta _tmpds;
20873 +    run;
20874 +    %end;
20875 +    proc datasets lib=work nolist;
20876 +      delete  _dmdbdat _dmdbcat _classout
20877 +    %if &recreatecmeta eq Y %then %do;
20878 +    _tmpds
20879 +    %end;
20880 +    ;
20881 +    quit;
20882 +%Mend MakeDummyVariables;
20883 +
20884 +/*--- Determine Optimal Number of Cluster ----
20885 +%macro FindClusNum(statds=, groupds=, minvariation=);
20886 +   %global optnclus;
20887 +   data varclus_tmp(drop=_NAME_);
20888 +      set &statDs;
20889 +      where _type_ ='PROPOR';
20890 +   run;
20891 +   proc sort data=varclus_tmp;
20892 +      by _NCL_;
20893 +   run;
20894 +   proc transpose data=varclus_tmp out=varclus_tmp;
20895 +      by _NCL_;
20896 +      var %EM_INTERVAL_INPUT
20897 +      %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
20898 +      %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
20899 +      %let nvar = %sysfunc(attrn(&dsid, NVAR));
20900 +          %do i = 2 %to &nvar;
20901 +          %let varname = %sysfunc(varname(&dsid, &i));
20902 +          &varname
20903 +          %end;
20904 +      %end;
20905 +   ;
20906 +   run;
20907 +
20908 +   %if &minVariation eq %then %do;
20909 +       %let minVariation = &EM_PROPERTY_MINVARIATION;
20910 +   %end;
20911 +   %if ^(0<&minVariation<100) %then %do;
20912 +       %let minVariation = 90;
20913 +   %end;
20914 +
20915 +   data _null_;
20916 +      set varclus_tmp end=eof;
20917 +      by _NCL_;
20918 +      retain flag 0;
20919 +      if first._ncl_ then flag=0;
20920 +      if .<col1 < &minVariation then flag=1;
20921 +      if last._ncl_ and ^flag then do;
20922 +         call symput('OPTNCL', _ncl_);
20923 +         stop;
20924 +      end;
20925 +     if eof then call symput('OPTNCL', _ncl_);
20926 +   run;
20927 +
20928 +   %let optnclus = &OPTNCL;
20929 +
20930 +   data varclus_tmp(drop=_NCL_ _NAME_);
20931 +      set &statDs;
20932 +      where _type_ in('RSQUARED' 'GROUP') and _NCL_=&OPTNCL;
20933 +   run;
20934 +   proc sort data=varclus_tmp;
20935 +      by _TYPE_;
20936 +   run;
20937 +   proc transpose data=varclus_tmp out=varclus_tmp;
20938 +      by _TYPE_;
20939 +   run;
20940 +   proc sort data=varclus_tmp;
20941 +      by _name_ _type_;
20942 +   run;
20943 +
20944 +  proc transpose data=varclus_tmp out=&groupds;
20945 +      by _NAME_;
20946 +   run;
20947 +   proc sort data=&groupDs(rename=(col1=Cluster col2=Rsquare _NAME_=VARIABLE));
20948 +      by Cluster descending Rsquare;
20949 +      where Cluster ne 0;
20950 +   run;
20951 +   proc datasets lib=work nolist mt=(DATA VIEW);
20952 +      delete varclus_tmp;
20953 +   run;
20954 +   quit;
20955 +%mend findClusNum;
20956 +*/
20957 +
20958 +%macro getNclusfromTrain(inoutstat=, nc=);
20959 +%global &nc;
20960 +data _null_;
20961 +    set &inoutstat end=eof;
20962 +    if eof then do;
20963 +    call symput("&nc", _ncl_);
20964 +    end;
20965 +run;
20966 +%mend  getNclusfromTrain;
20967 +
20968 +%macro MakeDeltaCode(groupds=, outstatscore=, deltacodefile=);
20969 +
20970 +     *--- Build Code to Modify Metadata ---*;
20971 +     filename X "&deltacodefile";
20972 +     data _null_;
20973 +        FILE X;
20974 +        set &groupds end=eof;
20975 +        /*by Cluster;*/
20976 +         if _N_=1 then do;
20977 +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
20978 +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
20979 +           %end;
20980 +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
20981 +           put "if upcase(strip(NAME)) in (";
20982 +        end;
20983 +        if Strip(upcase(Selected)) eq 'YES' then do;
20984 +           string = '"'!!trim(left(VARIABLE))!!'"';
20985 +           put string;
20986 +        end;
20987 +        if eof then do;
20988 +           put ') then ROLE="INPUT";';
20989 +           put 'else ROLE="REJECTED";';
20990 +           put 'end;';
20991 +
20992 +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
20993 +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
20994 +           %end;
20995 +        end;
20996 +     run;
20997 +     quit;
20998 +
20999 +     filename X;
21000 +
21001 +     quit;
21002 +%mend MakeDeltaCode;
21003 +
21004 +%macro MakeVarClusCorrData(statds=, corrds=, corrplotds= );
21005 +    %if ^%sysfunc(exist(&statds)) %then %do;
21006 +         %goto doendc;
21007 +    %end;
21008 +
21009 +    data &corrds(drop=_TYPE_ _NCL_) ;
21010 +       set &statds;
21011 +       where _type_ eq 'CORR' ;
21012 +    run ;
21013 +    proc sort data=&corrds;
21014 +       by _NAME_ ;
21015 +    run ;
21016 +    proc transpose data=&corrds out=&corrplotds name=_TMP_;
21017 +      BY _NAME_ ;
21018 +    run ;
21019 +    data &corrplotds;
21020 +       length _Y_ $100;
21021 +       set &corrplotDs;
21022 +       if _LABEL_ ne '' then _Y_=_LABEL_ ; else _Y_=_TMP_ ;
21023 +    run ;
21024 +    data varclus_match(rename=(_TMP_= _NAME_ _LABEL_=_X_));
21025 +       set &corrplotds;
21026 +       where _LABEL_ ne '' ;
21027 +       keep _TMP_ _LABEL_ ;
21028 +    run ;
21029 +    data _null_;
21030 +       nobs=0;
21031 +       dsid = open('varclus_match');
21032 +       if dsid then do;
21033 +          nobs = attrn(dsid, 'NOBS');
21034 +          dsid = close(dsid);
21035 +       end;
21036 +       call symput ('CORR_NOBS', nobs);
21037 +    run;
21038 +    %if &corr_nobs %then %do;
21039 +        proc sort data=varclus_match;
21040 +           by _name_;
21041 +        run ;
21042 +        proc sort data=&corrplotds;
21043 +           by _name_;
21044 +        run ;
21045 +        data &corrplotds(keep= _X_ _Y_ col1 rename=(col1=Correlation)) ;
21046 +           merge varclus_match &corrplotds;
21047 +           by _NAME_ ;
21048 +           if _X_ eq '' then _X_=_NAME_ ;
21049 +           label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
21050 +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
21051 +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
21052 +
21053 +       run ;
21054 +    %end;
21055 +    %else %do;
21056 +        proc sort data=&corrplotds;
21057 +           by _name_;
21058 +        run ;
21059 +        data &corrplotds(keep= _NAME_ _Y_ col1 rename=(_NAME_=_X_ col1=Correlation)) ;
21060 +           set &corrplotds;
21061 +           label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
21062 +           label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
21063 +           label col1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
21064 +
21065 +        run ;
21066 +    %end;
21067 +    proc sort data=&corrplotds;
21068 +       by _X_ _Y_;
21069 +    run ;
21070 +    proc datasets lib=work nolist mt=(DATA VIEW);
21071 +       delete varclus_match;
21072 +    run;
21073 +    quit;
21074 +
21075 +%doendc:
21076 +
21077 +%mend MakeVarClusCorrData;
21078 +
21079 +%macro MakeStatPlotData(statds= , outstatplotds=);
21080 +   %if %sysfunc(exist(&statds)) %then %do;
21081 +
21082 +       data varclus_tmp(drop=_NAME_ _NCL_) ;
21083 +          set &statDs;
21084 +          where _type_ in('MEAN', 'STD', 'N');
21085 +       run ;
21086 +       proc transpose data=varclus_tmp out=&outstatplotds;
21087 +          id _TYPE_ ;
21088 +       run ;
21089 +       data &outstatplotds;
21090 +          set &outstatplotds(obs=1000);
21091 +          label _name_= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_name, noquote))";
21092 +          label _label_="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
21093 +          if MEAN ne 0 then SCALEDSTD= STD / MEAN ;
21094 +          else SCALEDSTD= STD ;
21095 +          label SCALEDSTD = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_scaledstd, noquote))";
21096 +       run ;
21097 +       proc sort data=&outstatplotds;
21098 +          by descending SCALEDSTD ;
21099 +       run ;
21100 +       proc datasets lib=work nolist mt=(DATA VIEW);
21101 +          delete varclus_tmp;
21102 +       run;
21103 +       quit;
21104 +    %end;
21105 +
21106 +%mend MakeStatPlotData;
21107 +
21108 +
21109 +%macro CreateScoreCode(indata=, ncluscomp=, fileref=);
21110 +     %EM_GETNAME(KEY=OUTSTATSCORE, type=DATA);
21111 +    data &EM_USER_OUTSTATSCORE;
21112 +          set &indata;
21113 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
21114 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
21115 +          if _TYPE_ = 'STD' then _NAME_='STD';
21116 +          DROP _TYPE_ _NCL_;
21117 +     run;
21118 +
21119 +     filename _file_  "&fileRef";
21120 +
21121 +     data _null_;
21122 +        FILE _file_ MOD;
21123 +        put ' ';
21124 +        put '/*-------------------------------------------------*/';
21125 +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_begin , noquote))" '*/';
21126 +        put '/*-------------------------------------------------*/';
21127 +        put ' ';
21128 +        %let dsid = %sysfunc(open(&EM_USER_OUTSTATSCORE));
21129 +
21130 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
21131 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
21132 +
21133 +        %let k = 1;
21134 +        %do %while(^%sysfunc(fetch(&dsid)));
21135 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
21136 +                %if &k > 2 %then %do;
21137 +                 %let cn = %eval(&k-2);
21138 +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_cluscompnum, noquote, &cn))"  "------ */";
21139 +                %end;
21140 +                %let k = %eval(&k+1);
21141 +        %end;
21142 +
21143 +        %let rc = %sysfunc(rewind(&dsid));
21144 +
21145 +        %do i= 2 %to &nvar;
21146 +            %let _varname =  %sysfunc(varname(&dsid, &i));
21147 +            %do %while(^%sysfunc(fetch(&dsid)));
21148 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
21149 +                %if &_name = MEAN %then
21150 +                %let _mean = %sysfunc(getvarn(&dsid, &i));
21151 +                %else %if &_name = STD %then
21152 +                %let _std = %sysfunc(getvarn(&dsid, &i));
21153 +                %else %do;
21154 +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
21155 +                      %let abscoeff = %sysfunc(abs(&coeff));
21156 +                          %if &abscoeff >  0 %then %do;
21157 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
21158 +                           %end;
21159 +                 %end;
21160 +             %end;
21161 +             %let rc = %sysfunc(rewind(&dsid));
21162 +         %end;
21163 +
21164 +        %let dsid= %sysfunc(close(&dsid));
21165 +       run;
21166 +%mend CreateScoreCode;
21167 +
21168 +
21169 +
21170 +/*----------------------------------------------------------
21171 +    Instead of using %MakeRSquareData,
21172 +    %MakeVarClusResultTable at macro2.source is used
21173 + +----------------------------------------------------------*/
21174 +
21175 +
21176 +%macro MakeRSquareData(indata=, inClusRSquare=, outdata=, ncluster=);
21177 +
21178 +/* modifying  from ods rsquare = data */
21179 +
21180 +data &outdata(drop= ControlVar  NumberOfClusters CurrentCluster);
21181 +    Length Cluster $16;
21182 +    length Variable $32;
21183 +    Length VariableLabel $64;
21184 +    set &indata; retain CurrentCluster;
21185 +    if NumberOfClusters ^= &ncluster then delete;
21186 +    if strip(Cluster) eq '' then Cluster = CurrentCluster;
21187 +    CurrentCluster = Cluster;
21188 +   run;
21189 +proc sort data =&outdata ;
21190 +     by Cluster RsquareRatio;
21191 +run;
21192 +data _tmprsq(drop=index);
21193 +     set &outdata; by Cluster;
21194 +     if first.Cluster then do;
21195 +     index = strip(scan(Cluster,2 ));
21196 +     Variable = "Clus"||index;
21197 +     VariableLabel = "Cluster Component "||index;
21198 +     OwnCluster = 1;
21199 +     NextClosest = .;
21200 +     RsquareRatio = 0;
21201 +     output;
21202 +     end;
21203 +run;
21204 +
21205 +proc sort data = _tmprsq ;
21206 +     by Cluster RsquareRatio;
21207 +run;
21208 +data &outdata;
21209 +     set &outdata _tmprsq;
21210 +by Cluster;
21211 +run;
21212 +
21213 +
21214 +/* Just create the Selected variable with all YES */
21215 +
21216 +data &outdata;
21217 +    set &outdata; by cluster;
21218 +    length Selected $8;
21219 +    Selected = 'YES';
21220 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
21221 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
21222 +    rename OwnCluster = RSqWithClusterComp;
21223 +    rename NextClosest = RSqWithNextClusComp;
21224 +run;
21225 +
21226 +
21227 +/* Selected = Y/N will be done %score section -----
21228 +
21229 +%if &EM_PROPERTY_EXPORTEDCOMP ne CLUSTERCOMP %then %do;
21230 +data &outdata;
21231 +    set &outdata; by cluster;
21232 +    length Selected $8;
21233 +    if first.Cluster then Selected = 'YES';
21234 +    else Selected = 'NO';
21235 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
21236 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
21237 +    rename OwnCluster = RSqWithClusterComp;
21238 +    rename NextClosest = RSqWithNextClusComp;
21239 +run;
21240 +%end;
21241 +%else %do;
21242 +data &outdata;
21243 +    set &outdata; by cluster;
21244 +    if last.Cluster then Selected = 'YES';
21245 +    else Selected = 'NO';
21246 +    label  OwnCluster = 'R-Sqaure with Cluster Component';
21247 +    label  NextClosest = 'R-Sqaure with Next Cluster Component';
21248 +    rename OwnCluster = RSqWithClusterComp;
21249 +    rename NextClosest = RSqWithNextClusComp;
21250 +run;
21251 +%end;
21252 +---------------------------------------------------------------*/
21253 +
21254 +%if %sysfunc(exist(&inClusRSquare)) %then %do;
21255 +/* to calculate NextClosestClusRsq */
21256 +proc transpose data = &inClusRSquare  out=_clusRsq;
21257 +      by cluster;
21258 +      run;
21259 +data _clusRsq;
21260 +     set _clusRsq;
21261 +     if strip(upcase(Cluster)) eq strip(upcase(_NAME_)) then delete;
21262 +run;
21263 +
21264 +proc sort data=_clusRsq;
21265 +    by cluster col1;
21266 +    run;
21267 +data _clusRsq(drop=_NAME_ _LABEL_);
21268 +     set _clusRsq; by cluster;
21269 +     if last.Cluster then output;
21270 +     label  COL1 = 'R-Sqaure with Next Cluster Component';
21271 +     rename COL1 = RSqWithNextClusComp;
21272 +     rename Cluster = Variable;
21273 +     label  Cluster = "Variable";
21274 +run;
21275 +
21276 +proc sort data =&outdata;
21277 +     by Variable;
21278 +run;
21279 +data &outdata;
21280 +    merge &outdata _clusRsq;
21281 +    by Variable;
21282 +run;
21283 +proc sort data =&outdata;
21284 +by Cluster  RsquareRatio;
21285 +run;
21286 +quit;
21287 +%end;
21288 +
21289 +proc datasets lib = work nolist;
21290 +     delete _tmprsq _clusRsq;
21291 +     run;
21292 +quit;
21293 +
21294 +%mend MakeRSquareData;
21295 +
21296 +
21297 +/*-------------------------------------------------------------------------*/
21298 +
21299 +
21300 +
21301 +%macro ModifyCorr(indata=,
21302 +                  outdata=,
21303 +                  rsquare = Y
21304 +                  );
21305 +    data corr_tmp;
21306 +        set &indata;
21307 +    run;
21308 +     proc sql;
21309 +           update &indata
21310 +           set
21311 +     %let dsid = %sysfunc(open(work.corr_tmp));
21312 +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
21313 +          %do i = 4 %to &nvar;
21314 +          %let _name = %sysfunc(varname(&dsid, &i));
21315 +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
21316 +            %else  %let _name_md = &_name;
21317 +            %if &i < &nvar %then %do;
21318 +               &_name = 1- &_name_md ,
21319 +            %end;
21320 +            %else %do;
21321 +               &_name = &_name_md where _TYPE_ contains 'CORR' ;
21322 +            %end;
21323 +          %end;
21324 +      %let dsid= %sysfunc(close(&dsid));
21325 +
21326 +      select * from &indata;
21327 +      run;
21328 +      proc datasets lib = work nolist;
21329 +           delete corr_tmp;
21330 +      run;
21331 +      quit;
21332 +
21333 + %mend ModifyCorr;
21334 +
21335 + %macro MakeClusStructCorrData(indata=,outdata=, ncluster=, Rsquare=N);
21336 +    data &outdata(drop= _NCL_  _TYPE_);
21337 +       set &indata;
21338 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
21339 +       rename _NAME_ = Cluster;
21340 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
21341 +    run;
21342 +    %if &RSquare eq Y %then %do;
21343 +     data corr_tmp;
21344 +        set &outdata;
21345 +     run;
21346 +
21347 +     data &outdata(drop=i);
21348 +          set &outdata;
21349 +          %let dsid = %sysfunc(open(work.corr_tmp));
21350 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
21351 +          %do i = 2 %to &nvar;
21352 +            %let _name = %sysfunc(varname(&dsid, &i));
21353 +            %let _name_md = &_name.**2;
21354 +                &_name = &_name_md;
21355 +          %end;
21356 +      %let dsid= %sysfunc(close(&dsid));
21357 +      run;
21358 +      proc datasets lib = work nolist;
21359 +           delete corr_tmp;
21360 +      run;
21361 +
21362 +    %end;
21363 +     quit;
21364 +%mend MakeClusStructCorrData;
21365 +
21366 +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, RSquare=N, makeplotds=N, plotds=);
21367 +    data &outdata(drop= _NCL_  _TYPE_);
21368 +       set &indata;
21369 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
21370 +       rename _NAME_ = Cluster;
21371 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
21372 +    run;
21373 +    data corr_tmp;
21374 +        set &outdata;
21375 +    run;
21376 +
21377 +    %let dsid = %sysfunc(open(work.corr_tmp));
21378 +    %let nclus2= %eval(&ncluster+1);
21379 +    data &outdata;
21380 +         set &outdata;
21381 +          %do i = 2 %to &nclus2;
21382 +          %let i_1 = %eval(&i-1);
21383 +            %let _name = %sysfunc(varname(&dsid, &i));
21384 +            %let _newName = Clus&i_1;
21385 +                rename &_name = &_newName; ;
21386 +                *label &_name ="Cluster &i_1";
21387 +                label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
21388 +          %end;
21389 +          keep Cluster
21390 +          %do i = 2 %to &nclus2;
21391 +                %let _name = %sysfunc(varname(&dsid, &i));
21392 +                &_name
21393 +          %end;
21394 +          ;
21395 +    %let dsid= %sysfunc(close(&dsid));
21396 +     run;
21397 +     quit;
21398 +
21399 +    %if &RSquare eq Y %then %do;
21400 +
21401 +       data corr_tmp;
21402 +        set &outdata;
21403 +     run;
21404 +
21405 +     data &outdata(drop=i);
21406 +          set &outdata;
21407 +          %let dsid = %sysfunc(open(work.corr_tmp));
21408 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
21409 +          %do i = 2 %to &nvar;
21410 +            %let _name = %sysfunc(varname(&dsid, &i));
21411 +            %let _name_md = &_name.**2;
21412 +                &_name = &_name_md;
21413 +          %end;
21414 +      %let dsid= %sysfunc(close(&dsid));
21415 +      run;
21416 +    %end;
21417 +
21418 +    %if &makeplotds eq Y %then %do;
21419 +     proc transpose data = &outdata
21420 +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
21421 +          by cluster;
21422 +     run;
21423 +     data &plotds;
21424 +          set  &plotds;
21425 +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
21426 +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
21427 +     run;
21428 +     %end;
21429 +     proc datasets lib = work nolist;
21430 +           delete corr_tmp;
21431 +     run;
21432 +     quit;
21433 +%mend MakeInterClusCorrData;
21434 +
21435 +
21436 +%macro MakeClusConstellData(indata=, outlink=, outnode=);
21437 +
21438 +data &outlink(drop = Selected);
21439 +     set &indata;
21440 +     LINKID = _N_;
21441 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
21442 +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
21443 +run;
21444 +data &outnode(keep=NODEID TYPE LABEL);
21445 +    set &indata;
21446 +    length TYPE $16;
21447 +    rename Variable = NODEID;
21448 +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
21449 +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
21450 +    then  TYPE = "CLUSTER";
21451 +    else  TYPE="VARIABLE";
21452 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
21453 +run;
21454 +quit;
21455 +%mend MakeClusConstellData;
21456 +
21457 +
21458 +
21459 +%macro MakeClusConstellData(indata=, outlink=, outnode=);
21460 +
21461 +data &outlink(drop = Selected);
21462 +     set &indata;
21463 +     LINKID = _N_;
21464 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid,  noquote))";
21465 +     if strip(upcase(Cluster)) eq strip(upcase(Variable)) then Variable = ClosestCluster;
21466 +run;
21467 +data &outnode(keep=NODEID TYPE LABEL);
21468 +    set &indata;
21469 +    length TYPE $16;
21470 +    rename Variable = NODEID;
21471 +    label  Variable= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))";
21472 +    if strip(upcase(Cluster)) eq strip(upcase(Variable))
21473 +    then  TYPE = "CLUSTER";
21474 +    else  TYPE="VARIABLE";
21475 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))";
21476 +run;
21477 +quit;
21478 +%mend MakeClusConstellData;
21479 +
21480 +
21481 +/*--- This will work only when inds is not a view data -------
21482 +
21483 +%macro getNVarNObs(inds=, nvar=, nobs=);
21484 +
21485 +    %global &nvar;
21486 +    %global &nobs;
21487 +    data _null_;
21488 +         dsid = open("&inds");
21489 +         nv = attrn(dsid, 'NVAR');
21490 +         no = attrn(dsid, 'NOBS');
21491 +         dsid = close(dsid);
21492 +         call symput("&nvar", nv);
21493 +         call symput("&nobs", no);
21494 +    run;
21495 +    quit;
21496 +%mend  getNVarNObs;
21497 +
21498 ++---------------------------------------------------------------*/
21499 +
21500 +
21501 +%macro getNVar(inds=, nvar=);
21502 +    %global &nvar;
21503 +    data _null_;
21504 +         dsid = open("&inds");
21505 +         nv = attrn(dsid, 'NVAR');
21506 +         dsid = close(dsid);
21507 +         call symput("&nvar", nv);
21508 +    run;
21509 +    quit;
21510 +%mend  getNVar;
21511 +
21512 +
21513 +
21514 +%macro getNObs(inds=, nobs=);
21515 +    %global &nobs;
21516 +    data _null_;
21517 +        set &inds end=eof;
21518 +        if eof then call symput("&nobs", _N_);
21519 +    run;
21520 +    quit;
21521 +%mend  getNObs;
21522 +
21523 +%Macro CreateVarclusMeta(trainnum=);
21524 +   %EM_GETNAME(KEY=VARCLUSMETA, TYPE=DATA);
21525 +    data &EM_USER_VARCLUSMETA;
21526 +         length TrainNum 8.;
21527 +         length NewTrain $8;
21528 +         length NGCluster 8.;
21529 +         length ExportedComp $16;
21530 +         length HideVariable $8;
21531 +         TrainNum = &trainnum;
21532 +         NewTrain = "Y";
21533 +         ExportedComp = "&EM_PROPERTY_EXPORTEDCOMP";
21534 +         HideVariable = "&EM_PROPERTY_HIDEVARIABLE";
21535 +         NGCluster = 0; /* zero means no twostage */
21536 +   run;
21537 +   quit;
21538 +%mend CreateVarclusMeta;
NOTE: %INCLUDE (level 1) ending.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_MACROS2.SOURCE.
21539 +
21540 +%macro MakeInterClusCorrData(indata=, outdata=, ncluster=, globalclusid=, RSquare=N, makeplotds=N, plotds=);
21541 +    data &outdata(drop= _NCL_  _TYPE_);
21542 +       set &indata;
21543 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'CCORR') then delete;
21544 +       %if &globalclusid ne %then %do;
21545 +       _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
21546 +       rename _NAME_ = Cluster;
21547 +       %end;
21548 +       %else %do;
21549 +        _NAME_ = upcase(_NAME_);
21550 +       rename _NAME_ = Cluster;
21551 +       %end;
21552 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
21553 +    run;
21554 +    data corr_tmp;
21555 +        set &outdata;
21556 +    run;
21557 +
21558 +    %let dsid = %sysfunc(open(work.corr_tmp));
21559 +    %let nclus2= %eval(&ncluster+1);
21560 +    data &outdata;
21561 +         set &outdata;
21562 +          %do i = 2 %to &nclus2;
21563 +          %let i_1 = %eval(&i-1);
21564 +            %let _name = %sysfunc(varname(&dsid, &i));
21565 +            %if &globalclusid ne %then
21566 +                %do; %let _newName = GC&globalclusid._CLUS&i_1;
21567 +                     rename &_name = &_newName;
21568 +                     *label &_name ="GC &globalclusid : Cluster &i_1";
21569 +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gc_clusternum, noquote,  &globalclusid, &i_1))";
21570 +                %end;
21571 +            %else
21572 +                %do; %let _newName = CLUS&i_1;
21573 +                     rename &_name = &_newName;
21574 +                     *label &_name ="Cluster &i_1";
21575 +                     label &_name = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clusternum, noquote,  &i_1))";
21576 +                %end;
21577 +          %end;
21578 +          keep Cluster
21579 +          %do i = 2 %to &nclus2;
21580 +                %let _name = %sysfunc(varname(&dsid, &i));
21581 +                &_name
21582 +          %end;
21583 +          ;
21584 +    %let dsid= %sysfunc(close(&dsid));
21585 +     run;
21586 +     quit;
21587 +
21588 +    %if &RSquare eq Y %then %do;
21589 +
21590 +       data corr_tmp;
21591 +        set &outdata;
21592 +     run;
21593 +
21594 +     data &outdata;
21595 +          set &outdata;
21596 +          %let dsid = %sysfunc(open(work.corr_tmp));
21597 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
21598 +          %do i = 2 %to &nvar;
21599 +            %let _name = %sysfunc(varname(&dsid, &i));
21600 +            %let _name_md = &_name.**2;
21601 +                &_name = &_name_md;
21602 +          %end;
21603 +      %let dsid= %sysfunc(close(&dsid));
21604 +      run;
21605 +    %end;
21606 +
21607 +    %if &makeplotds eq Y %then %do;
21608 +     proc transpose data = &outdata
21609 +          out=&plotds(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
21610 +          by cluster;
21611 +     run;
21612 +     data &plotds;
21613 +          set  &plotds;
21614 +          label x="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
21615 +          label Y="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))";
21616 +          label  Correlation="%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))";
21617 +     run;
21618 +     %end;
21619 +     proc datasets lib = work nolist;
21620 +           delete corr_tmp;
21621 +     run;
21622 +     quit;
21623 +%mend MakeInterClusCorrData;
21624 +
21625 +%macro MakeOwnRSquare(indata=, outdata=, ncluster=, globalclusid=);
21626 +    data _tmpds(drop= _NCL_);
21627 +       set &indata;
21628 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) in ('GROUP','RSQUARED')) then delete;
21629 +       %if &globalclusid ne %then %do;
21630 +           _NAME_ = "GC&globalclusid.";
21631 +       rename _NAME_ = Cluster;
21632 +       %end;
21633 +       %else %do;
21634 +        _NAME_ = "CLUS";
21635 +        rename _NAME_ = Cluster;
21636 +       %end;
21637 +       label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername,  noquote))";
21638 +    run;
21639 +    proc transpose data =_tmpds out =&outdata;
21640 +    run;
21641 +
21642 +    data &outdata(drop=COL1);
21643 +        %if &globalclusid ne %then %do;
21644 +        length GCluster $16;
21645 +        %end;
21646 +        length Cluster $32;
21647 +        length _NAME_ $32;
21648 +         set &outdata;
21649 +         _NAME_ = upcase(_NAME_);
21650 +         rename _NAME_=Variable;
21651 +         *label _NAME_="Variable";
21652 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
21653 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
21654 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
21655 +
21656 +         %if &globalclusid ne %then %do;
21657 +          GCluster = "GC&globalclusid";
21658 +          Cluster = "GC&globalclusid._CLUS"||strip(COL1);
21659 +         %end;
21660 +         %else %do;
21661 +         Cluster = "CLUS"||strip(COL1);
21662 +        %end;
21663 +         rename COL2 = RSqWithOwnClusComp;
21664 +         *label COL2 = "R-Square With Own Cluster Component";
21665 +         label COL2 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
21666 +
21667 +   run;
21668 +   proc sort data =&outdata;
21669 +        by Cluster RSqWithOwnClusComp;
21670 +   run;
21671 +   proc datasets lib = work nolist;
21672 +           delete _tmpds;
21673 +   run;
21674 +   quit;
21675 +%mend MakeOwnRSquare;
21676 +
21677 +%macro MakeClusStructCorrData(indata=, outdata=, globalclusid=, ncluster=, Rsquare=N);
21678 +    data &outdata(drop= _NCL_  _TYPE_);
21679 +       %if &globalclusid ne %then %do;
21680 +        length GCluster $16;
21681 +        %end;
21682 +       set &indata;
21683 +       if ^(strip(_NCL_) eq &ncluster and strip(_TYPE_) eq 'STRUCTUR') then delete;
21684 +       %if &globalclusid ne %then %do;
21685 +         GCluster = "GC&globalclusid";
21686 +         _NAME_ = "GC&globalclusid._"||upcase(_NAME_);
21687 +         rename _NAME_ = Cluster;
21688 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
21689 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
21690 +
21691 +       %end;
21692 +       %else %do;
21693 +         _NAME_ = upcase(_NAME_);
21694 +         rename _NAME_ = Cluster;
21695 +         label _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
21696 +         label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
21697 +
21698 +       %end;
21699 +     run;
21700 +    %if &RSquare eq Y %then %do;
21701 +     data corr_tmp;
21702 +          set &outdata;
21703 +     run;
21704 +     %let istart = 2;
21705 +     %if &globalclusid ne %then %let istart = 3;
21706 +     data &outdata;
21707 +          set &outdata;
21708 +          %let dsid = %sysfunc(open(work.corr_tmp));
21709 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
21710 +          %do i =&istart %to &nvar;
21711 +            %let _name = %sysfunc(varname(&dsid, &i));
21712 +            %let _name_md = &_name.**2;
21713 +                &_name = &_name_md;
21714 +          %end;
21715 +      %let dsid= %sysfunc(close(&dsid));
21716 +      run;
21717 +      proc datasets lib = work nolist;
21718 +           delete corr_tmp;
21719 +      run;
21720 +    %end;
21721 +     quit;
21722 +%mend MakeClusStructCorrData;
21723 +
21724 +/*
21725 +%MakeClusStructCorrData(indata=playpen._outstat, outdata=_structrsq , ncluster=7, Rsquare=Y);
21726 +*/
21727 +
21728 +%macro FindNextClosestClusByVar(indata=, outdata=, globalclusid=, ncluster=);
21729 +
21730 +     /* The indata should be the outdata
21731 +        from %MakeClusStructCorrData(indata=, outdata=, ); */
21732 +
21733 +     proc sort data =&indata out=_tmpclusRsq;
21734 +     by cluster;
21735 +     run;
21736 +
21737 +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
21738 +      by cluster;
21739 +     run;
21740 +
21741 +     proc sort data=_tmpclusRsq;
21742 +        by _NAME_ COL1;
21743 +     run;
21744 +
21745 +     data _tmpclusRsq;
21746 +         length _NAME_ $32;
21747 +         set _tmpclusRsq; by _NAME_;
21748 +          _NAME_ = upcase(_NAME_);
21749 +          %if &ncluster ne 1 %then %do;
21750 +             if last._NAME_ then delete;
21751 +          %end;
21752 +          %else %do;
21753 +             COL1 = 0;
21754 +          %end;
21755 +     run;
21756 +     /* need to sort again */
21757 +     proc sort data=_tmpclusRsq;
21758 +        by _NAME_ COL1;
21759 +     run;
21760 +
21761 +     data &outdata;
21762 +         set _tmpclusRsq; by _NAME_;
21763 +         Cluster = upcase(Cluster);
21764 +         if last._NAME_ then output;
21765 +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
21766 +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
21767 +         rename COL1 = RSqWithNextClusComp;
21768 +         Cluster = upcase(Cluster);
21769 +         rename Cluster = ClosestCluster;
21770 +         *label  Cluster = "Next Closest Cluster";
21771 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
21772 +         rename _NAME_ = Variable;
21773 +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
21774 +    run;
21775 +
21776 +
21777 +    %if &globalclusid ne %then %do;
21778 +    data &outdata;
21779 +       length GCluster $16;
21780 +       set &outdata;
21781 +       GCluster = "GC&globalclusid";
21782 +       run;
21783 +    %end;
21784 +    proc datasets lib = work nolist;
21785 +           delete _tmpclusRsq;
21786 +    run;
21787 +    quit;
21788 +%mend FindNextClosestClusByVar;
21789 +
21790 +
21791 +%macro FindNextClosestClusByCluster(indata=, outdata=, globalclusid=, ncluster=);
21792 +     /* The indata should be the outdata from %MakeInterClusCorrData(indata=, outdata=, ); */
21793 +     proc sort data =&indata out=_tmpclusRsq;
21794 +     by cluster;
21795 +     run;
21796 +     proc transpose data =_tmpclusRsq out=_tmpclusRsq;
21797 +     by cluster;
21798 +     run;
21799 +     proc sort data=_tmpclusRsq;
21800 +        by _NAME_ col1;
21801 +     run;
21802 +     data _tmpclusRsq;
21803 +         length _NAME_ $32;
21804 +         set _tmpclusRsq; by _NAME_;
21805 +          _NAME_ = upcase(_NAME_);
21806 +          %if &ncluster ne 1 %then %do;
21807 +             if last._NAME_ then delete;
21808 +          %end;
21809 +          %else %do;
21810 +             COL1 = 0;
21811 +          %end;
21812 +     run;
21813 +     data &outdata;
21814 +         set _tmpclusRsq; by _NAME_;
21815 +         Cluster = upcase(Cluster);
21816 +         if last._NAME_ then output;
21817 +         *label  COL1 = 'R-Sqaure with Next Cluster Component';
21818 +         label COL1 = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextrsq, noquote))" ;
21819 +         rename COL1 = RSqWithNextClusComp;
21820 +         Cluster = upcase(Cluster);
21821 +         rename Cluster = ClosestCluster;
21822 +         *label  Cluster = "Next Closest Cluster";
21823 +         label Cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nextclus, noquote))" ;
21824 +         rename _NAME_ = Variable;
21825 +         *label  _NAME_ = "Variable";
21826 +         label  _NAME_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
21827 +
21828 +    run;
21829 +    %if &globalclusid ne %then %do;
21830 +    data &outdata;
21831 +       length GCluster $16;
21832 +       set &outdata;
21833 +       GCluster = "GC&globalclusid";
21834 +       run;
21835 +    %end;
21836 +
21837 +    proc datasets lib = work nolist;
21838 +           delete _tmpclusRsq;
21839 +    run;
21840 +
21841 +    quit;
21842 +%mend FindNextClosestClusByCluster;
21843 +
21844 +%macro MakeVarClusResultTable(indata1=, indata2=, indata3=, outdata=, globalclusid=, ncluster=, selectedcomp=clustercomp);
21845 +/*----
21846 +  indata1=_ownRsq, indata2=_nextVarRsq, indata3=_nextClusRSq,
21847 +-----------*/
21848 +
21849 +proc sort data =&indata1;
21850 +    by Variable;
21851 +run;
21852 +proc sort data =&indata2;
21853 +    by Variable;
21854 +run;
21855 +data &outdata;
21856 +    merge &indata1 &indata2;
21857 +    by Variable;
21858 +    length Type $16;
21859 +    Type = 'Variable';
21860 +    *label Type ='Type';
21861 +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
21862 +run;
21863 +
21864 +
21865 +data &indata3;
21866 +    set  &indata3 ;
21867 +    length RSqWithOwnClusComp 8.;
21868 +    Cluster = Variable;
21869 +    RSqWithOwnClusComp = 1;
21870 +    *label RSqWithOwnClusComp = "R-Square With Own Cluster Component";
21871 +    label RSqWithOwnClusComp = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_ownrsq, noquote))" ;
21872 +    length Type $16;
21873 +    Type = 'ClusterComp';
21874 +    label Type = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_type, noquote))" ;
21875 +
21876 +;
21877 +run;
21878 +
21879 +proc sort data=&outdata;
21880 +    by Cluster;
21881 +run;
21882 +proc sort data =&indata3;
21883 +    by Cluster;
21884 +run;
21885 +
21886 +data &outdata;
21887 +     set &outdata &indata3;
21888 +     by Cluster;
21889 +run;
21890 +
21891 +
21892 +/* Create the Selected variable with all YES */
21893 +
21894 +data &outdata;
21895 +     set &outdata;
21896 +     length RsqRatio 8.;
21897 +     length Selected $8;
21898 +     *label RSqRatio = "1-R**2 Ratio";
21899 +     label RSqRatio =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_oneminusrsq, noquote))" ;
21900 +     *label Selected = "Variable Selected";
21901 +     label Selected = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_varselected, noquote))" ;
21902 +     RsqRatio = (1-RSqWithOwnClusComp)/(1-RSqWithNextClusComp);
21903 +     Selected ='YES';
21904 +     rename _LABEL_ = Label;
21905 +     label _LABEL_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
21906 +run;
21907 +
21908 +
21909 +/*----  Selected = Y/N will be assigened at the %score                   -------+
21910 +        Just create the Selected variable with all YES at the step above
21911 + +------------------------------------------------------------------------------+
21912 +
21913 +proc sort data=&outdata;
21914 +    by Cluster RsqRatio;
21915 +run;
21916 +
21917 +%if &selectedcomp eq CLUSTERCOMP %then %do;
21918 +data &outdata;
21919 +     set &outdata; by Cluster;
21920 +     length Selected $8;
21921 +     label Selected = "Variable Selected";
21922 +     if  first.Cluster then Selected ='Yes';
21923 +     else Selected = 'No';
21924 +    run;
21925 +%end;
21926 +%else %do;
21927 +data &outdata(drop = _var _varchange);
21928 +     set &outdata; retain _var 0; by Cluster;
21929 +     length Selected $8;
21930 +     label Selected = "Variable Selected";
21931 +     if first.Cluster then  _varchange = 0;
21932 +     else _varchange =1;
21933 +     if _var ne _varchange then  Selected  = 'Yes';
21934 +     else Selected = 'No';
21935 +     if last.cluster then  _var = 0;
21936 +     else _var = _varchange;
21937 +run;
21938 +%end;
21939 +
21940 +--------------------------------------------------------------*/
21941 +
21942 +quit;
21943 +%mend MakeVarClusResultTable;
21944 +
21945 +%Macro MakePlotDataFromCorrTable(indata=, outdata=, globalclusid=);
21946 +     proc sort data =&indata;
21947 +        by cluster;
21948 +     run;
21949 +     proc transpose data =&indata
21950 +          out=&outdata(drop=_LABEL_ rename=(_NAME_ = Y Cluster=X Col1= Correlation));
21951 +          by cluster;
21952 +     run;
21953 +     data &outdata;
21954 +          set  &outdata;
21955 +          label x= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
21956 +          label Y= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
21957 +          label Correlation = "%sysfunc(sasmsg(sashelp.dmine, rpt_correlation_vlabel, noquote))" ;
21958 +     run;
21959 +     %if &globalclusid ne %then %do;
21960 +     data &outdata;
21961 +          Length GCluster $16;
21962 +          label GCluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
21963 +          set  &outdata;
21964 +          GCluster ="GC&globalclusid.";
21965 +          run;
21966 +     %end;
21967 +
21968 +%Mend MakePlotDataFromCorrTable;
21969 +
21970 +
21971 +%macro MakeCorrelation(indata=,
21972 +                       outstat=_tmpoutstat,
21973 +                       corrmatrix=N,
21974 +                       outcorr=_tmpoutcorr,
21975 +                       includeclassvar=N,
21976 +                       target=,
21977 +                       freq=,
21978 +                       weight=);
21979 +   %if &target eq  %then %do;
21980 +
21981 +       proc varclus data=&indata outstat=&outstat hi maxclusters=1 noprint;
21982 +            var %EM_INTERVAL_INPUT %EM_INTERVAL_REJECTED
21983 +       %if &includeclassvar eq Y %then %do;
21984 +          %let dsid = %sysfunc(open(&EM_USER_OUTDUMMY));
21985 +          %let nvar = %sysfunc(attrn(&dsid, NVAR));
21986 +          %do i = 2 %to &nvar;
21987 +          %let varname = %sysfunc(varname(&dsid, &i));
21988 +          &varname
21989 +          %end;
21990 +       %end;
21991 +       ;
21992 +      %if &freq ne  %then %do;
21993 +          freq &freq;
21994 +      %end;
21995 +      %if &weight ne  %then %do;
21996 +          weight &weight;
21997 +      %end;
21998 +
21999 +      run;
22000 +      %if &corrmatrix eq Y %then %do;
22001 +      data  &outcorr (drop = _NCL_ _TYPE_);
22002 +           set  &outstat ;
22003 +           if _TYPE_ ='CORR' then output;
22004 +      run;
22005 +      %end;
22006 +    %end;
22007 +    %else %do;
22008 +       proc corr data=&indata outp=&outstat noprint;
22009 +            var
22010 +       %let dsid = %sysfunc(open(&indata));
22011 +       %let nvar = %sysfunc(attrn(&dsid, NVAR));
22012 +          %do i = 1 %to &nvar;
22013 +              %let _name = %sysfunc(varname(&dsid, &i));
22014 +              %if &_name ne &target %then;
22015 +              &_name
22016 +           %end;
22017 +        %let dsid= %sysfunc(close(&dsid));
22018 +        ;
22019 +        with &target;
22020 +        run;
22021 +    %end;
22022 +    quit;
22023 +%mend MakeCorrelation;
22024 +
22025 +
22026 +%macro MakeCorrelationDistance(indata=,
22027 +                               outdata=,
22028 +                               rsquare = N
22029 +                               );
22030 +    data corr_tmp;
22031 +        set &indata;
22032 +        if _N_ = 1 then do;
22033 +           output;
22034 +           stop;
22035 +         end;
22036 +    run;
22037 +    %if &outdata ne  %then %let  _outdata = &outdata;
22038 +    %else %let _outdata = &indata;
22039 +
22040 +    data &_outdata;
22041 +         set &indata;
22042 +
22043 +         %let dsid = %sysfunc(open(work.corr_tmp));
22044 +         %let nvar = %sysfunc(attrn(&dsid, NVAR));
22045 +          %do i = 2 %to &nvar;
22046 +              %let _name = %sysfunc(varname(&dsid, &i));
22047 +              %if &rsquare eq Y %then %let _name_md = &_name.**2;
22048 +              %else  %let _name_md = &_name;
22049 +              &_name = 1- &_name_md;
22050 +          %end;
22051 +      %let dsid= %sysfunc(close(&dsid));
22052 +      run;
22053 +      proc datasets lib = work nolist;
22054 +           delete corr_tmp;
22055 +      run;
22056 +      quit;
22057 +  %mend MakeCorrelationDistance;
22058 +
22059 +
22060 +%macro UpdateOutStatCorrToDistance(indata=, /* indata should be a outstat from proc varclus */
22061 +                                   rsquare = N
22062 +                                   );
22063 +    data corr_tmp;
22064 +        set &indata;
22065 +    run;
22066 +    proc sql noprint;
22067 +           update &indata
22068 +           set
22069 +     %let dsid = %sysfunc(open(work.corr_tmp));
22070 +     %let nvar = %sysfunc(attrn(&dsid, NVAR));
22071 +          %do i = 4 %to &nvar;
22072 +          %let _name = %sysfunc(varname(&dsid, &i));
22073 +             %if &rsquare eq Y %then %let _name_md = &_name.**2;
22074 +            %else  %let _name_md = &_name;
22075 +            %if &i < &nvar %then %do;
22076 +               &_name = 1- &_name_md ,
22077 +            %end;
22078 +            %else %do;
22079 +               &_name = &_name_md where _TYPE_ eq 'CORR' ;
22080 +            %end;
22081 +          %end;
22082 +      %let dsid= %sysfunc(close(&dsid));
22083 +
22084 +      select * from &indata;
22085 +      run;
22086 +     data &indata( drop = _NCL_);
22087 +           set &indata;
22088 +           if _TYPE_ not in ('CORR', 'STD', 'N', 'MEAN') then delete;
22089 +           if _TYPE_ ='CORR' then _TYPE_ ='DISTANCE';
22090 +     run;
22091 +     data &indata(DROP = _NCL_);
22092 +           set &indata;
22093 +           if _TYPE_ = 'CORR' then _TYPE_ ='DISTANCE';
22094 +           if _TYPE_ not in ('DISTANCE', 'N', 'STD', 'MEAN') then delete;
22095 +           rename _NAME_ = _VAR_;
22096 +     run;
22097 +     proc datasets lib = work nolist;
22098 +           delete corr_tmp;
22099 +     run;
22100 +     quit;
22101 + %mend UpdateOutStatCorrToDistance;
22102 +
22103 +
22104 +%macro HierClusWithCorr(indata= ,
22105 +                        ncluster=,
22106 +                        method = Ward,
22107 +                        outtree = _outtree,
22108 +                        idvar =_VAR_,
22109 +                        outdata=,
22110 +                        rescore = N,
22111 +                        newncluster=
22112 +                        );
22113 +      %global &newncluster;
22114 +      %if &rescore ne Y %then %do;
22115 +      proc cluster data=&indata(type=Distance where=(upcase(strip(_TYPE_)) = "DISTANCE"))
22116 +                   method=&method outtree=&outtree noprint;
22117 +           id &idvar;
22118 +      run;
22119 +      %end;
22120 +      proc tree data=&outtree nclusters = &ncluster out=&outdata noprint;
22121 +      run;
22122 +      /* ----- Check some variables like CL1, CL5..., remove them ----*/
22123 +      proc contents data =&indata out=_outcontent(keep=NAME) noprint;
22124 +      run;
22125 +      data _outcontent;
22126 +          set _outcontent;
22127 +          if NAME in ('_TYPE_' , '_VAR_') then delete;
22128 +          index = 1;
22129 +          rename NAME = _NAME_;
22130 +      run;
22131 +      proc sort data=_outcontent;
22132 +          by _NAME_;
22133 +      run;
22134 +      proc sort data =&outdata;
22135 +           by _NAME_;
22136 +      run;
22137 +      data &outdata(drop=index);
22138 +          merge &outdata _outcontent;
22139 +          by _NAME_;
22140 +          if index = . then delete;
22141 +      run;
22142 +      /*-----------------------------------------------------------*/
22143 +      data &outdata;
22144 +           length CLUSNAME $16;
22145 +           set &outdata;
22146 +           if CLUSTER > &ncluster then delete;
22147 +           CLUSNAME='GC'||strip(CLUSTER);
22148 +           *label CLUSNAME = "Cluster Name";
22149 +           label CLUSNAME  = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_clustername, noquote))" ;
22150 +           rename _NAME_ = VARIABLE ;
22151 +           *label _NAME_ = "Variable";
22152 +           *label CLUSTER = "Cluster";
22153 +           label _NAME_ ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))" ;
22154 +           label CLUSTER ="%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, noquote))" ;
22155 +      run;
22156 +      proc sort data=&outdata out=&outdata;
22157 +           by CLUSTER;
22158 +      run;
22159 +      proc means data =&outdata noprint;
22160 +           output out=_meanout;
22161 +      run;
22162 +      data _null_;
22163 +            set _meanout;
22164 +            if strip(_STAT_) eq 'MAX' then do;
22165 +            call symput("&newncluster", CLUSTER);
22166 +            stop;
22167 +            end;
22168 +      run;
22169 +
22170 +      proc datasets lib = work nolist;
22171 +           delete _outcontent _meanout;
22172 +      run;
22173 +      quit;
22174 +%mend  HierClusWithCorr;
22175 +
22176 +%macro CreateScoreCode2(indata=, ncluscomp=, globalclusid=, fileref=);
22177 +
22178 +     data _tmpindata;
22179 +          set &indata;
22180 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = &ncluscomp ) or (_TYPE_ in ('MEAN' 'STD'));
22181 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
22182 +          if _TYPE_ = 'STD' then _NAME_='STD';
22183 +          if _TYPE_ = 'SCORE' then _NAME_=upcase("GC&globalclusid._"||_NAME_);
22184 +          DROP _TYPE_ _NCL_;
22185 +     run;
22186 +
22187 +     filename _file_  "&fileRef";
22188 +
22189 +     data _null_;
22190 +        FILE _file_ MOD;
22191 +        put ' ';
22192 +        put "/*-------------------------------------------------*/";
22193 +        put '/* ' "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_title_gclus, noquote, &globalclusid))" '*/';
22194 +        put "/*-------------------------------------------------*/";
22195 +        put ' ';
22196 +        %let dsid = %sysfunc(open(work._tmpindata));
22197 +
22198 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
22199 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
22200 +        %let k = 1;
22201 +        %do %while(^%sysfunc(fetch(&dsid)));
22202 +               %let _name = %sysfunc(getvarc(&dsid, &vn_name));
22203 +               %if &k > 2 %then %do;
22204 +                %let cn = %eval(&k-2);
22205 +                 put "&_name = 0 ; /*---" "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_score_gcluscompnum, noquote, &globalclusid, &cn))" "------ */";
22206 +                %end;
22207 +                %let k = %eval(&k+1);
22208 +
22209 +        %end;
22210 +        %let rc = %sysfunc(rewind(&dsid));
22211 +
22212 +        %do j= 2 %to &nvar;
22213 +            %let _varname = %sysfunc(varname(&dsid, &j));
22214 +            %do %while(^%sysfunc(fetch(&dsid)));
22215 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
22216 +                %if &_name = MEAN %then
22217 +                %let _mean = %sysfunc(getvarn(&dsid, &j));
22218 +                %else %if &_name = STD %then
22219 +                %let _std = %sysfunc(getvarn(&dsid, &j));
22220 +                %else %do;
22221 +                      %let coeff =  %sysfunc(getvarn(&dsid, &j));
22222 +                      %let abscoeff = %sysfunc(abs(&coeff));
22223 +                          %if &abscoeff >  0 %then %do;
22224 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
22225 +                           %end;
22226 +                 %end;
22227 +             %end;
22228 +             %let rc = %sysfunc(rewind(&dsid));
22229 +         %end;
22230 +
22231 +        %let dsid= %sysfunc(close(&dsid));
22232 +
22233 +     run;
22234 +
22235 +     filename _file_;
22236 +     proc datasets lib = work nolist;
22237 +           delete _tmpindata;
22238 +     run;
22239 +     quit;
22240 +%mend CreateScoreCode2;
22241 +
22242 +
22243 +%macro MakeDeltaCode2(groupds=,deltacodefile=);
22244 +
22245 +     /*--- Build Code to Modify Metadata ---*/
22246 +     filename X "&deltacodefile";
22247 +     data _null_;
22248 +        FILE X;
22249 +        set &groupds end=eof;
22250 +        if _N_=1 then do;
22251 +           %if &EM_PROPERTY_INCLUDECLASSVAR eq Y %then %do;
22252 +            put "if upcase(strip(ROLE)) ='INPUT' and upcase(strip(LEVEL)) ^='INTERVAL' then ROLE ='REJECTED' ;";
22253 +           %end;
22254 +           put "if upcase(strip(ROLE))='INPUT' and upcase(strip(LEVEL))='INTERVAL' then do;";
22255 +           put "if upcase(strip(NAME)) in (";
22256 +        end;
22257 +        if Strip(upcase(Selected)) eq 'YES' then do;
22258 +           string = '"'!!trim(left(VARIABLE))!!'"';
22259 +           put string;
22260 +        end;
22261 +        if eof then do;
22262 +           put ') then ROLE="INPUT";';
22263 +           put 'else ROLE="REJECTED";';
22264 +           put 'end;';
22265 +
22266 +           %if %upcase(&EM_PROPERTY_HIDEVARIABLE) eq Y %then %do;
22267 +             put 'if upcase(strip(ROLE)) = "REJECTED" then delete ;';
22268 +           %end;
22269 +        end;
22270 +     run;
22271 +     quit;
22272 +
22273 +     filename X;
22274 +     quit;
22275 +%mend MakeDeltaCode2;
22276 +
22277 +%macro getInitialGClusterNumber(indata=, ninput=, ndummy=0, div=100, ngc=);
22278 +  %global &ngc;
22279 +  data _null_;
22280 +  %if &indata ne %then %do;
22281 +      %let dsid = %sysfunc(open(&indata));
22282 +           %let nvar = %sysfunc(attrn(&dsid, NVAR));
22283 +      %let dsid = %sysfunc(close(&dsid));
22284 +  %end;
22285 +  %else %do;
22286 +       %let nvar = %eval(&ninput+&ndummy); ;
22287 +  %end;
22288 +  %let numgc = %eval(&nvar/&div+2);
22289 +  %let &ngc = &numgc;
22290 +   run;
22291 +  quit;
22292 +%mend getInitialGClusterNumber;
22293 +
22294 +
22295 +%macro MakeGobalConstellData(indata=, outlink=, outnode=);
22296 +data &outlink(drop = Selected);
22297 +     set &indata;
22298 +     LINKID = _N_;
22299 +     label LINKID = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_linkid, noquote))" ;
22300 +run;
22301 +data &outnode(keep=NODEID TYPE LABEL);
22302 +    set &indata;
22303 +    length TYPE $16;
22304 +    rename VARIABLE = NODEID;
22305 +    *label  CLUSNAME="Node ID";
22306 +    label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
22307 +    TYPE = "VARIABLE";
22308 +    *label TYPE = "Node Type";
22309 +    label TYPE =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
22310 +    run;
22311 +data _tmp(keep=NODEID TYPE LABEL);
22312 +    set &indata;
22313 +    length TYPE $16;
22314 +    rename CLUSNAME = NODEID;
22315 +    label  CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
22316 +    TYPE = "GCLUSTER";
22317 +    label TYPE = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
22318 +    run;
22319 +proc sort data=_tmp;
22320 +    by NODEID;
22321 +run;
22322 +data _tmp;
22323 +    set _tmp; by NODEID;
22324 +    if first.NODEID then output;
22325 +run;
22326 +proc sort data=&outnode;
22327 +    by NODEID;
22328 +run;
22329 +data  &outnode;
22330 +    set _tmp &outnode;
22331 +run;
22332 +proc datasets lib = work nolist;
22333 +     delete _tmp;
22334 +run;
22335 +quit;
22336 +%mend MakeGobalConstellData;
22337 +
22338 +/* Make contellation plot data among GCLUSTERS */
22339 +
22340 +%Macro MakeGClusterConstData(indata=, inoutrsq=, outnode=, outlink=);
22341 +
22342 +data &outlink(keep = _NAME_ _PARENT_ _LABEL_ LINKID);
22343 +     set &indata;
22344 +     LINKID = _N_;
22345 +     if upcase(substr(strip(_NAME_),1, 2))="CL" then do;
22346 +        _NAME_ = "ROOT"||upcase(substr(strip(_NAME_),5));
22347 +     end;
22348 +     if _PARENT_ ne " " and upcase(substr(strip(_PARENT_),1, 2))="CL" then do;
22349 +        _PARENT_ = "ROOT"||upcase(substr(strip(_PARENT_),5));
22350 +     end;
22351 +     if upcase(substr(strip(_LABEL_),1, 2))="CL" then do;
22352 +        _LABEL_ = "ROOT"||upcase(substr(strip(_LABEL_),5));
22353 +    end;
22354 +run;
22355 +
22356 +data _tmp_outrsquare;
22357 +        set &inoutrsq;
22358 +        if upcase(strip(TYPE)) = 'CLUSTERCOMP' then delete;
22359 +run;
22360 +
22361 +proc freq data =_tmp_outrsquare noprint;
22362 +         tables GCluster/out=_tmp_GCLUSFREQ(rename=(GCLUSTER=_NAME_));
22363 +run;
22364 +
22365 +data &outnode(keep=_NAME_ TYPE LABEL);
22366 +    set &outlink;
22367 +    length TYPE $16;
22368 +    length LABEL $100;
22369 +    /*label CLUSNAME= "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;*/
22370 +
22371 +    if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
22372 +    TYPE = "GCLUSTER";
22373 +    LABEL = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
22374 +    end;
22375 +    else do;
22376 +    TYPE= "ROOT";
22377 +    LABEL= _NAME_;
22378 +    end;
22379 +    label TYPE  =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodetype, noquote))" ;
22380 +    label LABEL =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_label, noquote))" ;
22381 +    label _NAME_ =  "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_nodeidvar, noquote))" ;
22382 +    run;
22383 +
22384 +proc sort data=&outnode;
22385 +     by _NAME_;
22386 +proc sort data=_tmp_GCLUSFREQ;
22387 +     by _NAME_;
22388 +run;
22389 +
22390 +data  &outnode;
22391 +     merge &outnode _tmp_GCLUSFREQ; by _NAME_;
22392 +     if COUNT=. then COUNT=1;
22393 +run;
22394 +
22395 +proc datasets lib = work nolist;
22396 +     delete _tmp_outrsquare _tmp_GCLUSFREQ;
22397 +run;
22398 +
22399 +quit;
22400 +%Mend MakeGClusterConstData;
22401 +
22402 +
22403 +%macro CreateGClusterScoreCode(indata=,  globalclusid=, fileref=);
22404 +
22405 +    data _gscoretmpds;
22406 +          set &indata;
22407 +          if (_TYPE_ in ('SCORE' 'MEAN' 'STD') and _NCL_ = 1 ) or (_TYPE_ in ('MEAN' 'STD'));
22408 +          if _TYPE_ = 'MEAN' then _NAME_='MEAN';
22409 +          if _TYPE_ = 'STD' then _NAME_='STD';
22410 +          if _TYPE_ = 'SCORE' then _NAME_ = "GC"||strip(&globalclusid);
22411 +          DROP _TYPE_ _NCL_;
22412 +     run;
22413 +
22414 +    /*  %let gscorefile =  %bquote(&EM_NODEDIR)&EM_DSEP.gclusterscore.sas;
22415 +        GCluster Component &globalclusid ------ */
22416 +
22417 +    filename _file_  "&fileref";
22418 +
22419 +    data _null_;
22420 +        %if &globalclusid eq 1 %then %do;
22421 +          FILE _file_;
22422 +        %end;
22423 +        %else %do;
22424 +          FILE _file_ MOD;
22425 +        %end;
22426 +
22427 +        %let dsid = %sysfunc(open(work._gscoretmpds));
22428 +        %let nvar = %sysfunc(attrn(&dsid, NVAR));
22429 +        %let vn_name =%sysfunc(varnum(&dsid, _NAME_));
22430 +
22431 +        %let k = 1;
22432 +        %do %while(^%sysfunc(fetch(&dsid)));
22433 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
22434 +                %if &k > 2 %then %do;
22435 +                put "&_name = 0 ; ";
22436 +                %end;
22437 +                %let k = %eval(&k+1);
22438 +        %end;
22439 +
22440 +        %let rc = %sysfunc(rewind(&dsid));
22441 +        %do i= 2 %to &nvar;
22442 +            %let _varname =  %sysfunc(varname(&dsid, &i));
22443 +            %do %while(^%sysfunc(fetch(&dsid)));
22444 +                %let _name = %sysfunc(getvarc(&dsid, &vn_name));
22445 +                %if &_name = MEAN %then
22446 +                %let _mean = %sysfunc(getvarn(&dsid, &i));
22447 +                %else %if &_name = STD %then
22448 +                %let _std = %sysfunc(getvarn(&dsid, &i));
22449 +                %else %do;
22450 +                      %let coeff =  %sysfunc(getvarn(&dsid, &i));
22451 +                      %let abscoeff = %sysfunc(abs(&coeff));
22452 +                          %if &abscoeff >  0 %then %do;
22453 +                       put "&_name = &_name+&coeff * (&_varname - &_mean)/&_std;";
22454 +                           %end;
22455 +                 %end;
22456 +             %end;
22457 +             %let rc = %sysfunc(rewind(&dsid));
22458 +
22459 +         %end;
22460 +
22461 +        %let dsid= %sysfunc(close(&dsid));
22462 +       run;
22463 +
22464 +
22465 +       proc datasets lib=work nolist;
22466 +            delete _gscoretmpds;
22467 +       run;
22468 +      quit;
22469 +
22470 +%mend CreateGClusterScoreCode;
22471 +
22472 +
22473 +%macro MakeGClusterCorrelation(Indata=, ngcluster=, gscorecode=, outrsquare=);
22474 +
22475 +   %EM_REGISTER(KEY=GSCORE, TYPE=DATA);
22476 +   %EM_GETNAME(KEY=GSCORE, TYPE=DATA);
22477 +   %EM_REGISTER(KEY=GSCORESTAT, TYPE=DATA);
22478 +   %EM_GETNAME(KEY=GSCORESTAT, TYPE=DATA);
22479 +   %EM_REGISTER(KEY=GSCORETREE, TYPE=DATA);
22480 +   %EM_GETNAME(KEY=GSCORETREE, TYPE=DATA);
22481 +   %EM_REGISTER(KEY=GSCORECORR, TYPE=DATA);
22482 +   %EM_GETNAME(KEY=GSCORECORR, TYPE=DATA);
22483 +   %EM_REGISTER(KEY=GSCORECORRPLOT, TYPE=DATA);
22484 +   %EM_GETNAME(KEY=GSCORECORRPLOT, TYPE=DATA);
22485 +   %EM_REGISTER(KEY=GCLUSLINK, TYPE=DATA);
22486 +   %EM_GETNAME(KEY=GCLUSLINK, TYPE=DATA);
22487 +   %EM_REGISTER(KEY=GCLUSNODE, TYPE=DATA);
22488 +   %EM_GETNAME(KEY=GCLUSNODE, TYPE=DATA);
22489 +
22490 +   filename gsfile "&gscorecode";
22491 +
22492 +   data &EM_USER_GSCORE;
22493 +             set &indata;
22494 +             %include  gsfile;
22495 +        keep
22496 +        %do i=1 %to &ngcluster;
22497 +         %let gcvarname = GC&i;
22498 +         &gcvarname
22499 +        %end;
22500 +     ;
22501 +   run;
22502 +
22503 +   proc varclus data=&EM_USER_GSCORE outstat=&EM_USER_GSCORESTAT outtree=&EM_USER_GSCORETREE
22504 +    %if %upcase(&EM_PROPERTY_CLUSCOMP) eq CENTROID %then %do; centroid %end;
22505 +    %if %upcase(&EM_PROPERTY_CLUSSOURCE) eq COV %then %do; cov %end;
22506 +    %if %upcase(&EM_PROPERTY_CLUSHIERACHY) eq Y %then %do; hi %end;
22507 +    noprint  ;
22508 +     var
22509 +       %do i=1 %to &ngcluster;
22510 +         %let gcvarname = GC&i;
22511 +         &gcvarname
22512 +        %end;
22513 +   ;
22514 +   run;
22515 +
22516 +
22517 +   %MakeVarClusCorrData(statds=&EM_USER_GSCORESTAT, corrds=&EM_USER_GSCORECORR, corrplotds=&EM_USER_GSCORECORRPLOT );
22518 +   data &EM_USER_GSCORECORRPLOT ;
22519 +        set &EM_USER_GSCORECORRPLOT;
22520 +        rename _X_ = X;
22521 +        rename _Y_ = Y;
22522 +        label _X_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
22523 +        label _Y_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote))" ;
22524 +   run;
22525 +
22526 +   %MakeGClusterConstData(indata=&EM_USER_GSCORETREE, inoutrsq=&outrsquare, outnode=&EM_USER_GCLUSNODE, outlink=&EM_USER_GCLUSLINK);
22527 +
22528 +   data &EM_USER_GSCORETREE;
22529 +        length _NAME_ $32;
22530 +        length _LABEL_ $100;
22531 +        set &EM_USER_GSCORETREE(DROP=_LABEL_);
22532 +        if upcase(substr(strip(_NAME_),1, 2))='GC' then do;
22533 +         _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_gcluster, noquote)):"||_NAME_;
22534 +        end;else do;
22535 +         _LABEL_ = _NAME_;
22536 +        end;
22537 +       label _LABEL_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_variable, noquote))";
22538 +
22539 +   run;
22540 +
22541 +   quit;
22542 +
22543 +%mend MakeGClusterCorrelation;
22544 +
22545 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_REPORT.SOURCE.
22546 +%macro report;
22547 +    %EM_GETNAME(key=VARCLUSMETA, type=DATA) ;
22548 +
22549 +    data _null_;
22550 +         set &EM_USER_VARCLUSMETA;
22551 +         if _N_=1 then
22552 +         call symput('_trainnum', TrainNum);
22553 +    run;
22554 +   %if (&_trainnum = 1 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = NO %then %do;
22555 +           filename temp catalog 'sashelp.emexpl.variableclustering_report1.source';
22556 +           %include temp;
22557 +           filename temp;
22558 +           %report1;
22559 +       %end;
22560 +   %if (&_trainnum = 2 ) or %upcase(&EM_PROPERTY_TWOSTAGECLUS) = YES %then %do;
22561 +           filename temp catalog 'sashelp.emexpl.variableclustering_report2.source';
22562 +           %include temp;
22563 +           filename temp;
22564 +           %report2;
22565 +    %end;
22566 +
22567 +   /* End of all runs, change the flag of newtrain to N */
22568 +    %EM_GETNAME(KEY=VARCLUSMETA, TYPE=DATA);
22569 +    data &EM_USER_VARCLUSMETA;
22570 +         set &EM_USER_VARCLUSMETA;
22571 +         NewTrain = "N";
22572 +    run;
22573 +    quit;
22574 +%mend report;
22575 +
22576 +
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      96709:166
NOTE: There were 1 observations read from the data set EMWS2.VARCLUS_VARCLUSMETA.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMEXPL.VARIABLECLUSTERING_REPORT1.SOURCE.
22577 +%macro report1;
22579 +   %EM_GETNAME(key=OUTRSQUARE, type=DATA) ;
22580 +   %EM_GETNAME(key=OUTVARSEL, type=DATA) ;
22581 +   %EM_GETNAME(key=CLUSFREQ, type=DATA) ;
22583 +   data &EM_USER_OUTVARSEL;
22584 +        set &EM_USER_OUTRSQUARE;
22585 +        if upcase(strip(SELECTED)) = 'YES' then output;
22586 +   run;
22588 +   data _tmp_outrsquare;
22589 +        set &EM_USER_OUTRSQUARE;
22590 +        if upcase(strip(TYPE)) = 'CLUSTERCOMP' then delete;
22591 +   run;
22593 +   proc freq data =_tmp_outrsquare noprint;
22594 +        tables cluster/out=&EM_USER_CLUSFREQ sparse;
22595 +   run;
22597 +   proc datasets lib = work nolist;
22598 +     delete _tmp_outrsquare;
22599 +   run;
22601 +   data &EM_USER_CLUSFREQ;
22602 +       set &EM_USER_CLUSFREQ;
22603 +       label
22604 +           cluster = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_cluster, NOQUOTE))"
22605 +           count   = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_freqcnt, NOQUOTE))"
22606 +           percent = "%sysfunc(sasmsg(sashelp.dmine, rpt_varclus_label_freqpct, NOQUOTE))"
22607 +       ;
22608 +   run;
22610 +   %EM_REPORT(key=OUTVARSEL, viewtype=DATA, block=MODEL, autodisplay=Y, description=selectedvariables);
22611 +   %EM_REPORT(key=CLUSFREQ, viewtype=DATA, block=MODEL, autodisplay=Y, description=varfreqbycluster);
22612 +   %EM_REPORT(key=OUTRSQUARE, viewtype=DATA, block=MODEL, autodisplay=Y, description=varseltable);
22614 +   %EM_REPORT(linkkey=OUTLINK, nodekey=OUTNODE, viewtype=Constellation,  autodisplay=Y, block=MODEL,  linkfrom=Cluster, linkto=Variable, linkid=LINKID, nodeid=NODEID, nodeshape=TYPE, description=clusterplot);
22615 +   %EM_REPORT(KEY=OUTTREE, VIEWTYPE=DENDROGRAM,  autodisplay=Y, block =MODEL, Name=NAME, PARENT=PARENT, HEIGHT=Proportion , TipText = Variable, description=dendrogram );
22616 +   %EM_REPORT(key=OUTRSQUARE, view = 1, viewtype=SCATTER, x=Cluster, y=RSqRatio, autodisplay=N, group=Selected, block=MODEL, description=rsqplot);
22617 +   %EM_REPORT(view = 1, y=RsqWithOwnClusComp);
22618 +   %EM_REPORT(view=1, y=RsqWithNextClusComp);
22619 +   %EM_REPORT(key=OUTCORRPLOT, viewtype=HISTOGRAM, X=_X_,Y=_Y_, FREQ=correlation, autodisplay=N, block=MODEL, description=varcorr);
22620 +   %EM_REPORT(key=OUTCLUSCORRPLOT, viewtype=HISTOGRAM, X=X,Y=Y, FREQ=Correlation, autodisplay=N, block=MODEL, description=cluscorr);
22621 +   %EM_REPORT(key=OUTCLUSSTRUCT, view=2, viewtype=BAR, block=MODEL, x=Cluster, freq=_anynumeric_ , autodisplay=N,  description=corrstruct) ;
22623 +   /*
22624 +   %EM_REPORT(KEY=OUTTREE, VIEWTYPE=DENDROGRAM,  autodisplay=N, block =Dendrogram, Name=_NAME_, Parent=_PARENT_, Height=_VAREXP_, TipText=Variable, description=totvar);
22625 +   %EM_REPORT(key=OUTCORR, viewtype=DATA, block=MODEL,description=corrmatrix) ;
22626 +   %EM_REPORT(key=OUTSTATPLOT, viewtype=DATA, block=MODEL, description=sumstat) ; */
22629 +%mend report1;
NOTE: %INCLUDE (level 1) ending.
NOTE: Fileref TEMP has been deassigned.
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_OUTVARSEL has 31 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 117 observations read from the data set EMWS2.VARCLUS_OUTRSQUARE.
NOTE: The data set WORK._TMP_OUTRSQUARE has 86 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: There were 86 observations read from the data set WORK._TMP_OUTRSQUARE.
NOTE: The data set EMWS2.VARCLUS_CLUSFREQ has 31 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: Deleting WORK._TMP_OUTRSQUARE (memtype=DATA).
 
NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 31 observations read from the data set EMWS2.VARCLUS_CLUSFREQ.
NOTE: The data set EMWS2.VARCLUS_CLUSFREQ has 31 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
 
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 264 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 264 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 396 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 396 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 528 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.02 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 528 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 660 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 660 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 793 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
 
 
 
NOTE: There were 793 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 926 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 926 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1059 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1059 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1192 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1192 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1325 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
 
 
 
NOTE: There were 1325 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1457 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
 
 
 
NOTE: There were 1 observations read from the data set EMWS2.VARCLUS_VARCLUSMETA.
NOTE: The data set EMWS2.VARCLUS_VARCLUSMETA has 1 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
22632  *------------------------------------------------------------*;
22633  * End REPORT: VarClus;
22634  *------------------------------------------------------------*;
22635
 
22636  /* Reset EM Options */
22637  options formchar="|----|+|---+=|-/\<>*";
22638  options nocenter ls=256 ps=10000;
22639  goptions reset=all device=GIF NODISPLAY;
 
22640  proc sort data=WORK.EM_USER_REPORT;
22641  by ID VIEW;
22642  run;
 
NOTE: There were 1457 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 1457 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
 
 
